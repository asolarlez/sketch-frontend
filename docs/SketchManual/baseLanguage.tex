\section{Core language}
The core sketch language is a simple imperative language that borrows most of its syntax from Java and C. 

\subsection{Primitive Types}
The sketch language contains five primitive types, \C{bit}, \C{int}, \C{char}, \C{double} and \C{float}. There is a subtyping relation between three of them:
\C{bit $~~~~~~\sqsubseteq~~~~~~$ char $~~~~~~\sqsubseteq~~~~~~$ int}, so bit variables can be used wherever a character or integer is required. 
\C{float} and \C{double} are completely interchangeable, but there is no subtyping relationship between them and the other types, so for example, you cannot use $1$ in place of $1.0$, or $0$ in place of $0.0$. 

There are two \C{bit} constants, \C{0}, and \C{1}. Bits are also used to represent Booleans; the constants \C{false} and \C{true} are syntactic sugar for \C{0} and \C{1} respectively. In the case of characters, you can use the standard C syntax to represent character constants. 

\paragraph{Modeling floating point} Floating point values (either \C{float} or \C{double}) are not handled natively by the synthesizer, so they have to be modeled using other mechanisms. The sketch synthesizer currently supports three different encodings for floating point values, which can be controlled by the flag \C{--fe-fpencoding}.

\flagdoc{fe-fpencoding}{ This flag controls which of three possible encodings are used for floating point values. \C{AS_BIT} encodes floating point values using a single bit; addition and subtraction are replaced with \C{xor}, and multiplication is replaced with \C{and}. Division and comparisons are not supported in this representation, nor are casts to and from integers. \C{AS_FFIELD} will encode floating points using a finite field of integers mod 7. This representation does support division, but not comparisons or casts. Finally, \C{AS_FIXPOINT} represents floats as fixed point values; this representation supports all the operations, but it is the most expensive. }


\subsection{Structs}
More interesting types can be constructed from simpler types in two ways: by creating arrays of them (see \secref{array}) and by defining new types of heap allocated records. 

To define a new record type, the programmer uses the following syntax (borrowed from C):
\begin{lstlisting}
struct $name${
  $type_1$ $field_1$;
  ...
  $type_k$ $field_k$;
}
\end{lstlisting}

To allocate a new record in the heap, the programmer uses the keyword \C{new}; the syntax is the same as that for constructing an object in Java using the default constructor, but the programmer can also use named parameters to directly initialize certain fields upon allocation as shown in the following example.

\begin{Example}
Use of named parameters to initialize the fields of a struct. 	
\begin{lstlisting}
struct Point{
  int x;
  int y;
}
void main(){
  Point p1 = new Point();
  assert p1.x == 0 && p1.y == 0; //Fields initialized to default values.

  Point p2 = new Point(x=5, y=7);
  assert p2.x == 5 && p2.y == 7; //Fields initialized by constructor.
}
\end{lstlisting}
\end{Example}

Records are manipulated through references, which behave the same way as references in Java. The following example illustrates the main properties of records and references in \Sk{}.

\begin{Example}
The example below will behave the same way as an equivalent example would behave in Java. In particular, all the asserts will be satisfied.
\begin{lstlisting}
struct Car{
  int license;
}

void main(){
  Car c = new Car(); // Object C1
  Car d = c;         // after assignment d points to C1
  c.license = 123;   // the field of C1 is updated.
  assert d.license == 123;
  strange(c, d);
  assert d.license == 123; //Object C1 unaffected by call
  assert d == c;
}

void strange(Car x, Car y){
  x = new Car();  //x now points to a new object C2
  y = new Car();  //y now points to a new object C3
  x.license = 456;
  y.license = 456;
  assert x.license == y.license;
  assert x != y; //x and y point to different objects
}
\end{lstlisting}

\end{Example}

Just like in Java, references are typesafe and the heap is assumed to be garbage collected (which is another way of saying the synthesizer doesn't model deallocation). A consequence of this is that a reference to a record of type T must either be \C{null} or point to a valid object of type T. All dereferences have an implicit null pointer check, so dereferencing \C{null} will cause an assertion failure.

\subsection{Temporary Structures}

There are instances where it is desirable to have the convenience of structures but without the cost of allocation and dereferencing, and without the burden of reasoning about aliasing. 

The language supports \emph{temporary structures}, which are unboxed, so they do not incur many of the usual costs associated with heap allocated structures. Temporary structures have copy semantics, so the programmer can think of them as primitive values and does not have to worry about aliasing. 

One can use temporary structures as local variables and parameters by enclosing the type of the structure in vertical bars \C{|type|}. Temporary structures can be created with a constructor \C{|type|($args$)}, where $args$ are named parameters just like with a normal constructor, but the keyword \C{new} is not used since nothing is being allocated in the heap. 

Temporary structures have the following properties:
\begin{itemize}
\item Assignment: assignment of a temporary structure to another results in a copy. 
\item Equality comparison: an equality comparison of two temporary structures is equivalent to the conjunction of their field-by-field comparison.
\end{itemize}

The following example illustrates the use of unboxed functions.

\begin{Example}
\begin{lstlisting}
struct Point{
   int x;
   int y;
}

...
|Point| p1 = |Point|(x=5, y=3); // temporary point initialized to (5,3).
Point p2 = new Point(x=3, y=2); // heap allocated point initialized to (3,2).
|Point| p3 = p1; // temporary point p3 is a copy of p1.
p3.x = 10;
Point p4 = p2; // p4 and p2 point to the same heap allocated object.
p4.x= 15;
assert p1.x == 5;
assert p2.x == 15;
assert p3.x = 10;
assert p4.x == 15;
if(??) assert p1 == p2; // equivalent to p1.x == p2.x && p1.y==p2.y
if(??) assert p1 != p2; // equivalent to !(p1==p2)
\end{lstlisting}
\end{Example}

\paragraph{Interaction of temporary and heap allocated structures}
An assignment from a heap allocated structure to a temporary structure is interpreted as a field-by-field copy. In the above example, an assignment \C{p3 = p2;} would be equivalent to 
\begin{lstlisting}
p3.x = px.x; p3.y = p2.y;
\end{lstlisting}
Such an assignment requires that \C{p2} not be \C{null}. Similarly, an assignment from a temporary structure to a heap allocated structure is also interpreted as a field-by-field copy, with a similar assertion that the reference will not be null. Failure to satisfy the assumption will cause an assertion failure. 

Similarly, an equality comparison of a heap allocated structure and a temporary structure will be equivalent to a field-by-field comparison.

\paragraph{Restrictions}
In the current version of the language, temporary structures are only allowed for local variables and function parameters. In particular, the language currently does not allow arrays of temporary structures or temporary structure fields in other structures. These restrictions are likely to be lifted in future versions of the language. Finally, structures with lists inside them are not allowed to be temporary structures.




\subsection{Final Types}\seclabel{final}
Just like in Java, \Sk{} has a notion of final variables and fields. Unlike Java, however, the language does not have a \C{final} keyword; finality is inferred based on a couple of simple rules. The rules for variables are shown below---there are analogous rules for fields of a record. 

\begin{itemize}
\item Any variable used as an l-value cannot be final; this includes variables used as the left hand side of an assignment, variables used with pre and post increments and decrements (\C{++x} or \C{--y}), and variables passed as reference parameters to another function (see \secref{functions}) .
\item Arrays cannot be final. 
\item Global variables can only be final if they are of scalar type (not references to records).
\end{itemize}

Since assignments to final variables are disallowed by the rules, final variables must be initialized upon declaration. For fields, final fields must be initialized upon allocation through the use of named parameters to the constructor.

Expressions can also be final if they are composed from final sub-expressions. In particular:

\begin{itemize}
\item Final variables are final.
\item A binary expression \C{a}  $op$  \C{b} is final if \C{a} and \C{b} are final.
\item A ternary expression \C{a ? b : c} is final if \C{a},\C{b} and \C{c} are final.
\item A field dereference \C{e.f} is final if \C{e} is a final expression and \C{f} is a final field.
\end{itemize}

Note that expressions involving function calls or side effects cannot be final. As we will see in the next section, final types will be relevant when specifying the sizes of arrays.

\subsection{Arrays}\seclabel{array}
The syntax for the array type constructor is as follows: if we want to declare a variable \C{a} to be an array of size \C{N} with elements of type \C{T}, we can declare it as:
\begin{lstlisting}
      T[N] a;
\end{lstlisting}
The language will automatically check that \C{N$\geq$0}.

The syntax for array access is similar to that in other languages; namely, the expression \C{a[x]} produces an element of type \C{T} when the type of \C{a} is \C{T[N]}, provided that \C{x<N}. All array accesses are automatically checked for array bounds violations.

The constructor above works for any type \C{T}, including other array types. This makes the semantics very simple, although it can be a little confusing for people who are used to working in languages with support for multi-dimensional arrays. To illustrate this point, consider the following example:
\begin{Example}
Consider the declaration below.
\begin{lstlisting}
int[N][M] a;
\end{lstlisting}
The type of \C{a} is \C{int[N][M]}. This means that for an \C{x < M}, \C{a[x] } is of type \C{int[N]}, and for any \C{y < N}, \C{a[x][y]} is of type \C{int}.   
\end{Example}

\paragraph{Dynamic Length Arrays}

When you declare an array of type \C{T[N]}, it is possible for \C{N} to be an arbitrary expression, as long as the expression is final as defined in \secref{final}. For example, consider the following code:
\begin{lstlisting}
harness void main(int n, int[n] in){
 int[n] out = addone(n, in);
}
int[n] addone(int n, int[n] in){
  int[n] out;
  for(int i=0; i<n; ++i){
    out[i] = in[i]+1;
  }
  return out;
}
\end{lstlisting}

The code above illustrates one of the most common uses of dynamic length arrays: allowing functions to take arrays of arbitrary size. There are a few points worth mentioning. First, note that the size in the return array of \C{addone} refers to one of the parameters of the function. In general, the output type can refer to any of the input parameters, as well as to any final global variables---\ie{} global variables that are assigned a constant value upon declaration and are never changed again. Similarly, the type of an input parameter can refer to any variable that comes before it. It is important to remember, however, that any expression used as the size of the array must be final, so in particular, they cannot involve any function calls.

When the size of the array needs to be computed by the function itself, there are two ways to proceed. One option is to give an over approximation of the size of the array as indicated by the example below. The other option is to package the array into a \C{struct} as shown in the next paragraph.

\begin{Example}
Consider a function that filters an array to return only those elements that are even. One cannot know the length of the return array a priori, because it depends on the data in the original array. One way to write such a function is as follows:
\begin{lstlisting}
int[N] filter(int N, int[N] in, ref int outsz){
	outsz = 0;
	int[N] out;
	for(int i=0; i<N; ++i){ 
		if(in[i]%2 == 0){
			out[outsz++] = in[i];			
		}
	}
	return out;
}
\end{lstlisting}
Notice that the function returns an array of size N, even though in reality, only the first \C{outsz} elements matter. The function uses a reference parameter (see \secref{functions}) to return \C{outsz}.
We may use the function as follows:
\begin{lstlisting}
int[N] tmp = filter(N, in, tsz);
int sz = tsz;
int[sz] filteredArray = tmp[0::sz];
\end{lstlisting}
The function uses the bulk array access \C{tmp[0::sz]}, which will be defined properly later in the section. A cleaner way of writing this example is to use records as shown in the next paragraph.
\end{Example}

\paragraph{Array fields}
Records can also have arrays as fields. The expression for the array size can involve any final expression in scope, which in practice means final expressions involving global variables and other final fields. Keep in mind that if a field is final, then it must be initialized by the constructor of the record. 

\begin{Example}
Using array fileds, we can write a cleaner version of the filter function from before:
\begin{lstlisting}
struct Array{
	int sz;
	int[sz] A;
}


Array filter(Array arr){
	int outsz = 0;
	int[arr.sz] out;
	for(int i=0; i<arr.sz; ++i){
		if(arr.A[i]%2 == 0){
			out[outsz++] = arr.A[i];
		}
	}
	return new Array(sz=outsz, A=out[0::outsz]);
}
\end{lstlisting}
One interesting point to note is the size of \C{out}; because it uses \C{arr.sz}, that forces both the variable \C{arr} and the field \C{sz} to be final. The field \C{sz} was already final because it was used in the size of field \C{A}, but now that \C{arr} is also required to be final; assigning anything to it inside the function would be illegal and would be flagged by the type checker. Finally, the function uses the bulk array access \C{out[0::outsz]}, which will be defined in the next section.
\end{Example}




\flagdoc{bnd-arr-size}{
If an input array is dynamically sized, the flag \C{--bnd-arr-size} can be used to control the maximum size arrays to be considered by the system. For any non-constant variable in the array size, the system will assume that that variable can have a maximum value of \C{--bnd-arr-size}. For example, if a sketch takes as input an array \C{int[N] x}, if \C{N} is another parameter, the system will consider arrays up to size \C{bnd-arr-size}. On the other hand, for an array parameter of type \C{int[N*N] x}, the system will consider arrays up to size \C{bnd-arr-size}$^2$.
}


\paragraph{Multi-dimensional arrays}
In sketch you can declare a multi-dimensional array as follows.
\begin{lstlisting}
T[$sz_0$, $sz_1$, $\ldots$, $sz_n$] A;
\end{lstlisting}
You can then access an element \C{A[$i_0$, $i_1$, $\ldots$, $i_n$]}, where $0\leq i_j < sz_n$. 

Multi-dimensional arrays are actually just syntactic sugar for nested arrays; so a declaration like the one above would be desugared to the one below.
\begin{lstlisting}
T[$sz_n$]$\ldots$[$sz_1$][$sz_0$] A;
\end{lstlisting}
And similarly, the access \C{A[$i_0$, $i_1$, $\ldots$, $i_n$]} is desugared to \C{A[$i_0$][$i_1$]$\ldots$[$i_n$]}. The nested array notation and the multi-dimensional array notation are completely interchangeable, so for example, it is fine to pass a nested array to a function expecting a multi-dimensional array, and vice-versa. 

The main advantage of the multi-dimensional array notation over the nested array notation is that the bounds in the declaration appear in the same order as the indexes in the array access, instead of being reversed as happens with the nested array notation.



\paragraph{Bulk array access}
The indexing operation we just saw will read a single element from an array. The \SK\ language also includes support for extracting sub-arrays out of an array. If \C{a} is an array of type \C{T[N]}, we can extract a sub-array of size \C{M} using the following expression: 
\begin{lstlisting}
a[x::M]
\end{lstlisting}

If \C{M} is greater than or equal to zero and \C{x + M $~\leq~$ N}, then the expression \C{ a[x::M]} produces an array of type \C{T[M]} containing the elements \C{a[x], ..., a[x+M-1]}. 

Bulk array access of the form \C{a[x::M]} will generate an exception if any index between \C{x} and \C{x+M-1} is out of bounds. Specifically, the system checks that \C{x>=0} and \C{x+M <= N}, where \C{N} is the size of \C{a}. Notice that if \C{M} is zero, then it is legal for \C{x} to equal \C{N}.

\paragraph{Array assignment}
The language also supports bulk copy from one array to another through array assignment operator. If \C{a} and \C{b} are arrays of type \C{T[N]}, then the elements of  \C{a} can be copied into \C{b} by using the assignment operator: 
\begin{lstlisting}
   b = a;
\end{lstlisting}
If \C{a:T[N]} and \C{b:T[M]} are of different size, then the assignment will be legal as long as \C{M $\geq$ N}. If \C{M $\neq$ N}, the rhs will be padded with zeros or nulls according to the rules in \secref{padding}.

Bulk array access operations can also serve as lvalues. For example, the assignment 
\begin{lstlisting}
b[2::4] = a[5::4] 
\end{lstlisting}
is legal---assuming of course that a and b are big enough for the bulk accesses to be legal. The effect of this operation is to write values a[5], a[6], a[7], a[8] into locations b[2], b[3], b[4], b[5]. For such an assignment, the compiler will read all the values in the right hand side before writing anything to the left hand side. This is relevant when reading and writing to the same array. For example, the assignment 
\begin{lstlisting}
a[0::3] = a[1::3] 
\end{lstlisting}
will read values  \C{a[1], a[2], a[3]} before writing to locations  \C{a[0], a[1], a[2]}.

\paragraph{Array constants}
\seclabel{ainit}
Sketch supports C-style array constants. An array constant of k-elements is expressed with the following syntax.
\begin{lstlisting}
{ a1, a2, ... , ak}
\end{lstlisting}
Array constants in \Sk{} are more flexible than in C. They are not restricted to array initialization; they can be used anywhere an array rvalue can be used. In particular, the following are all valid statements in sketch:
\begin{lstlisting}
int[3] x = {1,2,3};
x[{1,2}[a]] = 3;
x[0] = {4,5,6}[b];
x[{0,1}[a]::2] = {0,1,2,3,4,5,6}[b::2];
\end{lstlisting}

\paragraph{String literals (Character array constants)}
Like C, sketch supports strings in double quotes as a shorthand for a null-terminated character arrays. So for example, the string \C{"a string"} is a shorthand for the array constant:
\begin{lstlisting}
{'a', ' ', 's', 't', 'r', 'i', 'n', 'g', '\0'}
\end{lstlisting}


\paragraph{Nested array constants}
The entries \C{a1} through \C{ak} in the array initializer can themselves be arrays, which makes it possible for the system to support nested array initializers. The type for an array initializer will be defined by the following rule:
\[
	\frac{\tau = \bigsqcup \tau_i~~~ \Gamma\vdash a_i:\tau_i }{\Gamma \vdash \{a_0, a_1, \ldots a_{k-1}\}:\tau[k]}
\]
Given two array types $\tau_1[N]$ and $\tau_2[M]$, the type $\tau_1[N] \sqcup \tau_2[M]$ is equal to $(\tau_1 \sqcup \tau_2)[max(N,M)]$. The system pads the nested array initializers according to the rules in \secref{padding}. For example, an array of the form
\begin{lstlisting}
{{1,2},{1},{1,2,3},{1}}
\end{lstlisting}
will be of type int[3][4], and will be equivalent to the following array:
\begin{lstlisting}
{{1,2,0},{1,0,0},{1,2,3},{1,0,0}}
\end{lstlisting}


\paragraph{Array Equality.} The equality comparison recursively compares each element of the array and works for arrays of arbitrary types. In addition to comparing each element of the array, the equality comparison also compares the sizes of the array, so arrays of different sizes will be judged as being different even if after padding they would have been the same.
In general, two arrays \C{a:T[n]} and \C{b:T[m]} will be compared according to the following recursive definition:

\begin{lstlisting}
	a == b when a and b have type T[n] $\Rightarrow$ n==m $\wedge \forall$ i < n a[i]==b[i]
	a == b when a is of type T[n] and b is of type T $\Rightarrow$ n==1 $\wedge$ a[0] == b
\end{lstlisting}
In the second line, it is assumed that T is a non-array type. There is a symmetric case when \C{a} is of a non-array type.


\begin{Example}
Given two arrays, \C{int[n][m] y} and \C{int[m][n] z}, the following assertion will always succeed:
\begin{lstlisting}
if(x==y){
	assert n==m;
}
\end{lstlisting}
That is because the only way \C{x} and \C{y} can be equal is if their dimensions are equal. Similarly, given two arrays \C{int[p][n][m] a} and \C{int[t] b}, the assertion below will always succeed:
\begin{lstlisting}
if(a==b){
	assert t==m && n==1 && p == 1;
}
\end{lstlisting}
\end{Example}


\paragraph{Bit Vectors}
While a sketch programmer can create arrays of any arbitrary type, arrays of bits allow an extended set of operations to allow programmers to easily write bit-vector algorithms. The set of allowed operators is listed below, and the semantics of each operator is the same as the equivalent operator for unsigned integers in C.
\begin{center}
\begin{tabular}{r}
\lstinline!bit[N] & bit[M] $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] | bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] ^ bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] + bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] >> int    $\rightarrow$ bit[N]!\\
\lstinline!bit[N] << int    $\rightarrow$ bit[N]!\\
!\lstinline!bit[N] $\rightarrow$ bit[N]!\\
\end{tabular}
\end{center}

Notice that most operators support operands of different sizes; the smaller array is padded to match the size of the bigger array according to the rules of padding from \secref{padding}. 



\subsection{Algebraic Data types}\seclabel{adts}
Sketch also supports algebraic data types, or case classes as they are known in Scala. To illustrate the use of algebraic data types (ADTs), consider the \C{Tree} ADT defined below. 
\begin{lstlisting}
struct Tree{}

struct Leaf extends Tree{
	int value;
}
struct Branch extends Tree{
	Tree left;
	Tree right;
}
\end{lstlisting}
\C{Tree} is an ADT by virtue of having two variants that extend it: \C{Leaf} and \C{Branch}. Both \C{Leaf} and \C{Branch} can be instantiated just like any other kind of record, and they are both subtypes of \C{Tree}. For example, the code below instantiates a small tree.

\begin{lstlisting}
Tree t1 = new Leaf(value=5);
Tree t2 = new Leaf(value=6);
Tree t3 = new Leaf(value=7);
Tree t = new Branch(left=t1, right=new Branch(left=t2, right=t3));
\end{lstlisting}
The fact that Leaf and Branch extend \C{Tree} causes \C{Tree} to be abstract, so \C{Tree} itself cannot be instantiated. 

Pattern matching in \Sk{} is done through the \C{switch} construct. The basic syntax is as follows:
\begin{lstlisting}
switch(var){
   case C1: 
   ...
   case Cn:
}
\end{lstlisting}
The argument \C{var} passed to switch must be a variable whose type is an ADT, and each case must be labeled with a different variant \C{Ci}. Within that case, the variable \C{var} will automatically acquire the type corresponding to the case. This is illustrated by the function below: 



\begin{lstlisting}
int sum(Tree t){
   int v=0;
   switch(t){
      case Leaf:{
        /*t is now of type Leaf in this block */
        v = t.value;
      }
      case Branch:{
        /*t is now of type Branch is this block */
        v = sum(t.left)+sum(t.right);
      }
   }        
   /*Outside the switch, t goes back to being of type Tree*/
   return v;
}
\end{lstlisting}
The \C{switch} construct looks a lot like the \C{switch} construct in C or Java, but its semantics are very different. First, the cases correspond to the possible types of \C{t}, as opposed to different values of an integer expression. Second, the argument to switch must be a variable, and the type of this variable will be different in each of the cases. And finally, the cases do not ``fall through'' the way they do in C; only one case can match, and only the block of code associated with the matching case will execute.

The language allows hierarchies of ADTs. For example:
\begin{lstlisting}
struct ASTNode{}
struct Expression extends ASTNode{}
struct Statement extends ASTNode{}
struct Plus extends Expression{Expression left; Expression right;}
struct Times extends Expression{Expression left; Expression right;}
struct IfStmt extends Statement{Expression cond; Statement tpart; Statement epart;}
struct WhileStmt extends Statement{Expression cond; Statement body;}
\end{lstlisting}
So in this case, one can create instances of \C{Plus}, \C{Times}, \C{IfStmt} and \C{WhileStmt}, but not of \C{ASTNode} or of \C{Expression} and \C{Statement}. When pattern matching, however , one can have cases for \C{Expression} or \C{Statement} and those cases will match on any variant that is a subtype of them. 

The following are some additional rules associated with ADTs. 
\begin{itemize}
\item Records representing an ADT can have fields, and those fields will be inherited by all the variant types.
\item A parent and a variant \C{struct} cannot both have a field with the same name. 
\item The type extended by a variant class should exist and be defined in the same package, so ADT definitions cannot span multiple packages (see \secref{pkg} for more on packages).
\item The expression that is passed to switch(e) should always be a variable, and the labels for the cases should be variants of the type of that variable.
\item Switch statements should cover all the cases.
\item Implicit casting occurs from a subtype to a super type.
\item Explicit casts can happen only from a supertype to a subtype. An incorrect cast will cause an assertion failure. 
\end{itemize}



\subsection{Automatic Padding and Typecasting}
\seclabel{padding}
When arrays are assigned or passed as parameters, they can be implicitly typecast through padding. Padding is also supported by bit vector operations, but not for reference parameters. This padding can be thought of as an implicit typecast from small arrays to bigger arrays. The objects used to pad the array depend on the type of the array. Given an array of type \C{T[N]}, the objects used to pad the array will be defined by the function \lstinline!$pad$(T)! defined by the following rules:
\begin{lstlisting}
$pad$(int) = 0 
$pad$(bit) = 0
$pad$(struct) = null
$pad$(T[N]) = $\{pad$(T)$,\ldots, pad$(T)$\}$ //N copies of $pad$(T)
\end{lstlisting}

\begin{Example}
In the statement \lstinline!int[4] x = {1,2};!, the right hand side has size 2, but will be implicitly cast to an array of size 4 by padding it with the value \lstinline!$pad$(int)=0!, so after the assignment, \C{x} will equal \lstinline!{1,2,0,0}!.
\end{Example}


\begin{Example}
Padding also works for assignments involving nested arrays.
\begin{lstlisting}
int[2][2] x = {{2,2}, {2,2}};
int [4][4] y = x;
\end{lstlisting}

The code above involves the following implicit typecasts: first, the array x of type \C{int[2][2]} is typecast into an array of type \C{int[2][4]} by padding with \lstinline!$pad$(int[2])={ $pad$(int), $pad$(int)} = {0, 0}! to produce the array \lstinline!{{2,2}, {2,2}, {0,0}, {0,0}}!. Then, each entry in this array is typecast from \C{int[2]} to \C{int[4]}, so after the assignment, the value of \C{y} will be equal to \lstinline!{{2,2,0,0}, {2,2,0,0}, {0,0,0,0}, {0,0,0,0}}!
\end{Example}


A second form of implicit typecasting happens when a scalar is used in place of an array. In this case, the scalar is automatically typecast into an array of size 1 or zero depending on the context.

\begin{Example}
Consider the following block of code 
\begin{lstlisting}
struct Car{ ... }
...
Car[4] x;
Car t = new Car();
x = t;
\end{lstlisting}
This code actually involves two typecasts. First, \C{t} will be typecast from the scalar type \C{Car} to the array type \C{Car[1]}. Then, the array type \C{Car[1]} will be typecast to a bigger array of type \C{Car[4]} by padding with \lstinline!$pad$(Car) = null!. The result is that array will be equal to \lstinline!{t, null, null, null}!.
\end{Example}

There are some cases where it is desirable to assign a constant to an array of size \C{n}, where \C{n} may be an input to the function. If \C{n} is zero, however, the constant will automatically be cast to an empty array of size zero in order to avoid an error.

\begin{Example}
\begin{lstlisting}
int[n] x;
...
x = 0; // This will zero out the array; will not cause an error when n==0
\end{lstlisting}
\end{Example}


The casting of scalars to arrays of size 1 also works in the context of multidimensional arrays.
\begin{Example}
The following block of code illustrates padding for multi-dimensional arrays.
\begin{lstlisting}
struct Car{ ... }
...
Car[2] x = {new Car(), new Car()};
Car[4][3] y = x;
assert y[0][0] == x[0];
assert y[1][0] == x[1];
assert y[1][1::3] == {null, null, null};
assert y[2] == {null, null, null, null};
\end{lstlisting}
\end{Example}

To understand the example above, it is worth thinking of an array assignment of the form \C{y=x} where \C{y} is of type \C{T[N]} as a loop of the form 
\begin{lstlisting}
for(int i=0; i<N; ++i){
   if(i<M)//where M<=N is the size of x
     y[i] = x[i];
   else
     y[i] = $pad$(T);
}
\end{lstlisting}
So in the example above, \C{y[i]} will be of type \C{Car[4]} and \C{x[i]} will be of type \C{Car}, which means each assignment involves an implicit typecast from \C{Car} to \C{Car[4]}.


\subsection{Explicit Typecasting}
The \Sk{} language also offers some limited explicit typecasting. In particular, the language offers only four explicit typecasts:
\begin{itemize}

\item An array \C{a} of type \C{T[N]} can be explicitly typecast into an array of type \C{T[M]} by using the syntax \C{(T[M])a} (standard typecast notation from C). When an array is typecast to a smaller size, the remaining elements are simply truncated. 

\item A bit array \C{bit[N]} can be explicitly typecast into an integer. When this happens, the first bit in the array is interpreted as the least significant bit and the last one as the most significant bit. The reverse cast from an integer to a bit array is not supported.

\item If using \C{--fe-fpencoding AS_FIXPOINT}, explicit casts from integers to floating point values and vice versa are also allowed.
\item An object of an algebraic data type can be explicitly typecast to one of its variants. The system will automatically introduce an assertion to ensure that the value is of the right type. For example, in the \C{Tree} example from \secref{adts}, one can cast a value of type \C{Tree} into a value of type \C{Leaf}, but if the value is a \C{Branch} instead of a \C{Leaf}, the cast will trigger an assertion failure.
\end{itemize}

\begin{Example}
One instance where explicit casting is useful is when comparing an array against the zero array.
\begin{lstlisting}
int[N] x=...;
assert x == (bit[N])0;
\end{lstlisting}
Notice that in the code above, if we had written simply \C{x==0} in the assertion, the assertion would have been violated when \C{N>1}, because the scalar zero is treated as an array of size 1. By casting the constant zero into an array of size \C{N}, we ensure that x is compared against an array of size \C{N} consisting of all zeros.
\end{Example}

\begin{Example}
Explicit casting is also useful when copying one dynamically sized array into another one.
\begin{lstlisting}
int[N] x=...;
int[M] y = (bit[M])x;
\end{lstlisting}
If we knew that \C{N} is smaller than \C{M}, we could have written simply \C{y=x}, and the automatic padding would have made the assignment correct. Similarly, if we knew that \C{M} is smaller than or equal to \C{N}, assigning \C{y=x[0::M]} would have been legal. However, \C{y=x} fails when \C{M} is smaller than \C{N}, and x[0::M] fails when \C{M>N}. The cast on the other hand succeeds in both cases and has the expected behavior.
\end{Example}

\subsection{Control Flow}
The language supports the following constructs for control flow: \C{if-then}, \C{while}, \C{do-while}, \C{for}. These have the same syntax and semantics as in \C{C/C++} or \C{Java}. The language does not support a C-like \C{switch} statement, since \C{switch} is used for pattern matching instead (see \secref{adts}). The language also does not support \C{continue} and \C{break}, although they can easily be emulated with \C{return} by using closures (see \secref{closures}).

The synthesizer reasons about loops by unrolling them. The degree of unrolling is controlled by a flag \C{--bnd-unroll-amnt}. If the loop iteration bounds are static, however, the loop will be unrolled as many times as necessary to satisfy the static bounds. 

\flagdoc{bnd-unroll-amnt}{This flag controls the degree of unrolling for both loops and \C{repeat} constructs}


\begin{Example}
Consider the three loops below.
\begin{lstlisting}
for(int i=0; i<N; ++i){...}
for(int i=0; i<100; ++i){...}
for(int i=0; i<N && i<7; ++i){...}
\end{lstlisting}
If \C{N} is an input variable, the first loop will be unrolled as many times as specified by \C{--bnd-unroll-amnt}. The second loop will be unrolled \C{100} times regardless of the value of the flag (as long as there are no return statements in its body). For the third loop, the unroll factor will be controlled by the flag, but will never exceed seven.
\end{Example}



\subsection{Functions}
\seclabel{functions}
The sketch language also supports functions. The syntax for declaring a function is the same as in C. 

\begin{lstlisting}
$ret\_type$ $name$($args$){
  $body$
}
\end{lstlisting}

\paragraph{Recursion}
The synthesizer reasons about function calls by inlining them into their calling context. In principle, this could be problematic for recursive functions, but in practice this usually is not a problem. The synthesizer uses a flag \C{bnd-inline-amnt} to bound the maximum number of times a function can be inlined. If any input requires inlining more than the allowed number of times, synthesis will fail.

\flagdoc{bnd-inline-amnt}{Bounds the amount of inlining for any function call. The value of this parameter corresponds to the maximum number of times any function can appear in the stack.}

\flagdoc{bnd-bound-mode}{ The solver supports two bound modes: \C{CALLSITE} and \C{CALLNAME}. In \C{CALLNAME} mode (the default), the flag \C{bnd-inline-amnt} will bound the number of times any function appears in the stack. In the \C{CALLSITE} mode, the \C{bnd-inline-amnt} flag will bound the number of times a given \emph{call site} appears on the stack, so if the same function is called recursively multiple times, each site is counted independently. 
}


\paragraph{Reference Vs. Value Parameter Passing}
By default, parameter passing is done by value, so even if parameters are modified inside the function, the change will not be visible outside. We can make changes to a parameter visible to the caller by prefixing the formal parameter with the keyword \C{ref} as shown in the example below.

\begin{Example}
Prefixing the formal parameter with \C{ref} makes changes visible outside the function.
\begin{lstlisting}
void foo(int in, ref int out){
	in = in + 1; // changes to in are not visible to the caller
      out = in + 1; //changes to out are 
}
harness void main(int x){
      int y = x;
	int z = y+10;
      foo(y, z); // call to foo can change z but not y
      assert y == x && z == x+2;
}
\end{lstlisting}
\end{Example}

A very important point about \C{ref} parameters is that their semantics is not actually pass-by-reference; it is copy-in-copy-out. If you pass only local variables by reference and you never alias \C{ref} parameters, copy-in-copy-out semantics and pass-by-reference semantics are indistinguishable, and the compiler will actually generate pass-by-reference code. However, if you alias parameters or if you pass a field of a record by reference, the copy-in-copy-out semantics will become apparent.

\begin{Example}
This example illustrates copy-in-copy-out semantics.
\begin{lstlisting}
void foo(ref int p1, ref int p2){
      int t=p1;
      p1 = p1 + 1;
      p2 = p2 + 2;
      assert p1 == t + 1;
}
harness void main(int x){
	int z = x;
      foo(z, z); 
      assert z == x+2;
}
\end{lstlisting}
Note that copy-in-copy-out semantics make it possible to reason about \C{foo} in isolation; the assertion will hold regardless of whether or not the user passes the same parameter to \C{foo} twice. The copy-out happens in the order of the parameter list, so the final value of \C{z} is the value of \C{p2}.
\end{Example}

Another very important point is that the \C{ref} modifier can also be used in generator functions ((see \secref{generators}), but in that case, \C{ref} parameters do have pass-by-reference semantics.


\paragraph{Implicit size parameters}

When passing arrays as parameters, it is common to have to separately pass the size of the array, so a typical function signature will look like this:
\begin{lstlisting}
double[n] foo(int n, double[n] in)
\end{lstlisting}

\Sk{} allows you to declare the size parameter \C{n} as an \emph{implicit parameter} so that you do not have to pass it when calling the function.

\begin{lstlisting}
double[n/2] foo([int n], double[n] in){//brackets signify implicit parameter
     return in[0::n/2];
}
harness void main(int n, double[n] in){
   double[n/2] res = foo(in); //we don't have to pass n.
   double[n] res = foo(2*n, in);//but we can if we want.
}
\end{lstlisting}

The syntax for a function definition that uses implicit parameters is shown below. 
\begin{lstlisting}
$ret\_type$ $name$([$implicit~args$], $args$){
  $body$
}
\end{lstlisting}
Specifically, implicit parameters must be at the beginning of the parameter list, and the complete list of implicit parameters must be enclosed in square brackets.

There are two important semantic requirements for implicit parameters. First, all implicit parameters must be of integer type, since they must correspond to sizes of arrays passed as parameters. The second requirement is that every implicit parameter must be equal to the size of at least one array argument.

\begin{Example}
The following definitions correspond to legal uses of implicit parameters:
\begin{lstlisting}
int[n] foo([int n, int m], int[n] a, int[m] b)...
int[m] foo([int n], int[n] a, int m, int[m] b)...
int[n+m] foo([int n, int m], int[n][m] a, int[m] b)...
int[n+m] foo([int n, int m], int[n][m] a, int[2*m] b)...
\end{lstlisting}
By contrast, the following are all illegal:
\begin{lstlisting}
int[n] foo([int n, int m], int[n] a)... // m is not used
int[n] foo([int n], int[n*2] a)... //n is not the size of any array param
int[n+m] foo([int n, int m], int[n][m*2] a, int[m-1] b)... //m is not the size of any array param
\end{lstlisting}
\end{Example}

When calling a function with implicit parameters, there are two rules to keep in mind.
\begin{itemize}
\item You can decide to pass all implicit parameters, or you can pass none of them, but you cannot selectively pass only a subset of them.
\item If a given implicit parameter is used by multiple array parameters, all array parameters must be consistent regarding the value of that parameter.
\end{itemize}

\begin{Example}
Given the following function definition and declarations
\begin{lstlisting}
void foo([int n, int m], int[n] a, int[m][n] b)...
...
int[5] w;
int[5] x;
int[3][5] y;
int[10] z;
\end{lstlisting}
The following calls are valid:
\begin{lstlisting}
foo(x, y); // n==5, m==n
foo(w, x); // n==5, m==1
foo(10, 3, z, y); // Involves an implicit cast for y.
\end{lstlisting}

By contrast, the following are all illegal:
\begin{lstlisting}
foo(z, y); //different value of n for the two arrays
foo(3, z, y); //Passes only a subset of implicit parameters
\end{lstlisting}
\end{Example}



\subsection{Function parameters}
Functions can also take other functions as parameters. We use the keyword \C{fun} to denote a function type. The example below illustrates the use of function parameters.
\begin{Example}
Functions as parameters.
\begin{lstlisting}
int apply(fun f, int x){
	return f(x);
}
int timesTwo(int x){
	return x+x;
}

harness void main(int x){
	assert apply(timesTwo, x) == 2*x;
}
\end{lstlisting}
\end{Example}

The language imposes several restrictions on the use of the \C{fun} type. First, the type can only be used for parameters. You cannot declare a variable or a data-structure field of type \C{fun}. There are also no operators defined for functions; in particular, the ternary operator \C{?:} cannot be used with functions. You can also not create arrays of functions, and you cannot use functions as return values or reference parameters to a function. In short, functions are not quite first class citizens in \Sk{}, but function parameters do enable some very useful idioms.

One important point to notice about function parameters is that the signature does not specify what parameters it expects. This gives the language some flexibility, and in some cases allows one to make up for the fact that we don't have generics. However, it also has an important implication. Namely, when a function parameter is called, it is not possible to know which parameters will be reference parameters and which parameters will not, so any variable that is passed to a function that came as a parameter will be considered non-final.

\subsection{Local functions and closures}\seclabel{closures}
Sketch supports the definition of functions inside other functions. The syntax for doing this is the same as when the function is defined outside a function. The body of the locally defined function can access any variable that is in scope in the context of the function definition. The example below illustrates how local functions can be used together with high-order functions. 

\begin{lstlisting}
void ForLoop(fun f, int i, int N){
	if(i<N){
		f(i);
		ForLoop(f, i+1, N);
	}
}

harness void main(int N, int[N] A){
	int[N] B;
	void copy(int i){
		B[i] = A[i];
	}
	ForLoop(copy, 0, N);
	assert A == B;
}
\end{lstlisting}
	
In the sketch above, \C{ForLoop} takes the closure involving the function \C{copy} and its local environment; the effect of the call to \C{ForLoop} is the same as if the body of copy had been placed in a traditional \C{for} loop. 
One important aspect of closures in Sketch is that because functions cannot be returned by other functions or written into the heap, a local function can never escape the context in which it was declared. This allows local functions to modify local variables defined in their host function without any messy semantic issues.

Finally, local functions can only be used after they are declared, unlike top level functions for which the order of declaration does not matter. One important implication of this is that you cannot define mutually recursive local functions.

\begin{lstlisting}
harness void main(int N, int[N] A){
      int foo(int i){
        if(i>0){
             return moo(i-1); // not allowed because moo has not been declared.
        }
        return i;
      }
      int moo(int i){
         return foo(i);
      }
}
int fooTop(int i){
      if(i>0){
        return mooTop(i-1); // This is ok, for top level functions the 
      }                     // order of declaration does not matter.
      return i;
}
int mooTop(int i){
     return fooTop(i);
}
\end{lstlisting}


\subsection{Lambda Functions}

Lambda functions are functions without a name. They are also known as \textit{anonymous functions}. They allow the creation of a function without specifying a name and return type. The syntax to define a lambda is TODO \C{(vars) -> expression}. Lambdas are used as actual parameters of high-order functions or initializers to variables of type \C{fun}.

\begin{Example}
Passing a lambda to a high order function.
\begin{lstlisting}
int apply(fun f, int x) {
    return f(x, 5);
}

harness void main() {  
    int result = apply((x, y) -> x + y, 7);
         
    assert result == 12; 
}
\end{lstlisting}

\end{Example}

\begin{Example}
Defining a variable of type \C{fun}.
\begin{lstlisting}
harness void main() {     
    int t = 3;
    fun foo = (x) -> t * x;
            
    assert foo(2) == 6; 
}
\end{lstlisting}

\end{Example}

Lambda functions must be defined and used in the local scope or in local functions. The body of the lambda function can be any valid expression in the language. The formal parameters of the lambda function cannot be used as l-values.

Lambda functions cannot be defined inside \C{struct} nor can they be returned from a function. These are the same restrictions on the usage of local function (see Section 2.12). Variables of type \C{fun} are final and cannot be modified once they are initialized.

\begin{Example}
Using two local variable constructs of different types inside a local function.
\begin{lstlisting}
harness void main() {  
    bit t = 1;    
    int a = 2;
    int b = 3;
    
    int foo() {
        fun g = () -> $\$$(bit) ? 5 : $\$$(int);
        return g();
    }

    assert foo() == 3;
}
\end{lstlisting}

\end{Example}


\begin{Example}
Using a local variable construct inside a local function that is passed to a high-order function.
\begin{lstlisting}
int apply(fun f) {
    return f();
}

harness void main(int x) {
  int a = 1;
  int b = 2;
  
  int foo() {
      fun f = () -> $\$$(int);
      return f();
  }
  
  int t = apply(foo)*??;
  
  assert t == x + x;
}
\end{lstlisting}

\end{Example}


\subsection{Uninterpreted Functions}
\Sk{} also supports uninterpreted functions, which can be defined with the following syntax.
\begin{lstlisting}
$ret\_type$ $name$($args$);
\end{lstlisting}
An uninterpreted function is a function whose body is unknown, so from the point of view of the synthesis and verification engine; there is nothing known about this function other than the fact that it is a pure function, so when fed with the same inputs it will produce the same outputs. Importantly, if you are using an uninterpreted function to model some complex routine in the program, you need to make sure that routine behaves as a mathematical function; i.e. it should not access the heap or global variables. For this reason, we restrict uninterpreted functions so they can not involve structures.


\subsection{Packages}\seclabel{pkg}

The \Sk{} language supports packages. A package is identified by the \C{package} statement at the beginning of a file.
\begin{lstlisting}
package PACKAGENAME;
\end{lstlisting}

All the functions and structures defined in a file must belong to the same package, so the compiler will produce an error if there is more than one package definition in a file. If a file does not have a \C{package} command, then by default its contents will belong to the package \C{ANONIMOUS}. Also, note that unlike Java, package names cannot have periods or other special symbols. 

A file can import other packages by using the \C{include} command. The syntax of the command is shown below. The string in quotes corresponds to the name of the file where the package resides. 

\begin{lstlisting}
include "file.sk";
\end{lstlisting}

The include command should not be confused with the \C{#include} preprocessor directive, which simply inlines the contents of a file and is not really part of the language. 

\flagdoc{fe-inc}{
The command line flag {--fe-inc} can be used to tell the compiler what directories to search when looking for included packages. The flag works much like the \C{-I} flag in gcc, and can be used multiple times to list several different directories.
}

Each package defines its own namespace, allowing the system to avoid name conflicts. Code in one package can explicitly refer to functions or structures defined in another package by using the \C{@} notation. For example, a call of the form \C{foo@pk()} will call a function \C{foo} defined in package \C{pk}. Similarly, a declaration of the form \C{Car@vehicles c = new Car@vehicles()} defines a new object of type \C{Car}, where the type was defined in the package \C{vehicles}. In the absence of an explicit package name, the system will search for definitions of functions and structures as follows:
\begin{itemize}
\item If the name is defined locally in the same package, the local definition will be used.
\item If the name is not defined locally in the same package, but is only defined in one other package (so there is no ambiguity), then the definition in that other package will be used.
\item If the name is not defined locally in the same package and the same name is defined in multiple packages, then you need to explicitly name the package or you will get a compiler error.
\end{itemize}
\begin{Example} The example below illustrates the use of packages.\newline
\begin{tabular}{cp{2cm}c}
\begin{lstlisting}
// Begin file farm.sk
package farm;
struct Goat{
   int weight;  }
struct Ram{
   int age;     }
struct Mouse{
   int age;     }
// End file farm.sk
\end{lstlisting} & ~ &
\begin{lstlisting}
// Begin file computer.sk
package computer;
struct Cpu{
   int freq;    }
struct Ram{
   int size;    }
struct Mouse{
   bit isWireless; }
// End file computer.sk
\end{lstlisting}
\end{tabular}
\begin{lstlisting}
//Begin file test.sk
include "computer.sk";
include "farm.sk";
struct Mouse{
   int t;  
}
harness main(){
   Cpu c = new Cpu(); // No ambiguity here.
   Ram@farm r = new Ram@farm() //Without @farm, this would be an error.
   Ram@computer rc = new Ram@computer();
   Mouse m = new Mouse(); // Give preference to the locally defined mouse.
   m.t = 10;
}
//End file test.sk
\end{lstlisting}
\end{Example}

\subsection{Global variables}
The sketch language supports global variables with a few important restrictions.
\begin{itemize}
\item First, global variables are always private to the package in which they are defined; they cannot be made public, although you can have functions in a package that read and write to a given global variable. 
\item The second restriction is a consequence of the fact that only scalar global variables can be final; this means that global arrays must have constant dimensions since, in that scope, constants are the only thing that can be final.

\item The initializers for global variables can only involve side-effect-free expressions of constants and final global variables. An expression that allocates a struct (\eg{} \C{new C(a=x)}) is considered a side-effect-free expression as long as the arguments to the constructor (\eg{} \C{x}) are side effect free. Division, array access and function calls are not considered side-effect free since they may fail.
\end{itemize}

\subsection{Annotation System}
The \Sk{} language includes an annotation system that is meant to simplify the process of adding language extensions. The general syntax for annotations is as follows:
\begin{lstlisting}
@Name(parameter-string)
\end{lstlisting}
\C{Name} is the name of the annotation and \C{parameter-string} is a string describing the parameters of the annotation. Annotations are currently only supported for function and record definitions. 

The synthesizer currently supports two annotations. The first is \C{@Native}, which allows the user to override the standard code generator and tell the synthesizer exactly what code to synthesize for a particular function. The second one is \C{@NeedsInclude} which is used to tell the code generator that a particular function requires some specific header file to be included.

For example, the following code shows how the two \C{@Native} annotations can be used to write a set of routines that read form a file.

\begin{Example}
In \Sk{}, one can use the following classes to model the process of reading from a file.

\begin{lstlisting}
int NDCNT=0;

int getND_private(int i);
int getND(){
    //Every time this function is called
    //it produces a new non-deterministic value.
    return getND_private(NDCNT++);
}

struct FileHandle{
    int maxReads; //Number of values left in the file.
}

FileHandle getFile(){
    //Number of values in the file is some non-deterministic value.
    return new FileHandle(maxReads=getND());
}

bit moreValues(FileHandle fh){
    //maxReads should never drop below zero.
    assert fh.maxReads >= 0; 
    return fh.maxReads!=0;
}

int readInt(FileHandle fh){
    //Reads past the end of the file are not allowed.
    assert fh.maxReads > 0;
    --fh.maxReads; 
    return getND();
}
\end{lstlisting}

The \C{FileHandle} is initialized with the maximum number of values to read. Every time the client calls \C{readInt}, the synthesizer reads checks if the maximum number of reads has been reached and reads another non-deterministic value. This definition of the operations on a file is very good if we are interested in synthesizing or verifying a client that needs to read a file and do something with its contents. However, if we want to generate code to read real files, the class above is not so useful. 

Using the \C{@Native} annotations, however, we can instruct the synthesizer on how to generate code for the structure and functions above. For example, the code for the \C{struct} would be as follows:

\begin{lstlisting}
struct FileHandle{
    int maxReads;
    @NeedsInclude("#include <fstream>")
    @NeedsInclude("#include <string>")
    @Native("ifstream in;")
    @Native("int last;")
    @Native("bool goon;")
    @Native("FileHandle(const string& s):in(s.c_str()){ in>>last; goon = !in.eof() && !in.fail(); }")
    @Native("int readInt(){ int x = last; in>>last; goon = !in.eof() && !in.fail(); return x;}")
}
\end{lstlisting}
The functions annotations are used to introduce additional fields and methods which are invisible to the analysis engine, but which are needed by the generated code. 

With their annotations, the \C{moreValues} and \C{readInt} functions are as follows:
\begin{lstlisting}
@Native("{ _out = fh->goon; }")
bit moreValues(FileHandle fh){
    assert fh.maxReads >= 0; 
    return fh.maxReads!=0;
}


@Native("{ _out = fh->readInt(); }")
int readInt(FileHandle fh){
    assert fh.maxReads > 0;
    --fh.maxReads; 
    return getND();
}
\end{lstlisting}

When analyzing code, the annotations are invisible to the synthesizer, and it will focus on the high-level model in the body. When generating code, on the other hand, the code generator will produce the code instructed by the \C{@Native} annotation.

\end{Example}

The \C{@Native} annotation allows the programmer to use simple models in place of very complex or low-level functions. It is the responsibility of the programmer to ensure that the model matches the relevant behavior of the code that is being generated. 

More generally, if you want to write custom extensions to the \Sk{} synthesizer, you can use annotations to pass information to your custom extension without affecting any of the existing synthesizer infrastructure. 

