
pragma options "--bnd-inbits 2 --beopt:simiters 5 --beopt:-bndwrand 32";

int size = 7;

//sourceAST
adt sourceAST{
	SNum {int val;}
	SVar { int str;}
	STrue {}
	SFalse {}
	SAssign {int str; sourceAST a;}
	SLet {int str; sourceAST a; sourceAST b;}
	SPrim1 {opcode op; sourceAST a;}
	SPrim2 {opcode op; sourceAST a; sourceAST b;}
	SBetween {sourceAST a;sourceAST b;sourceAST c;}
}

adt opcode{
	Oplus{int a;}
	Ominus{}
	Oneg{}
	Oand{}
	Oor{}
	Onot{}
	Ogt{}
	Olt{}	
}

//CoreAST
adt coreAST{
	CNum {int val;}
	CVar {int str;}
	CBool {bit v;}
	CPrim1 {opcode op; coreAST a;}
	CAssign {int str; coreAST a;}
	CLet {int str; coreAST a; coreAST b;}
	CPrim2 {opcode op; coreAST a; coreAST b;}
}


coreAST desugar(sourceAST s, int bnd){
	if(s == null){ return null; }
	if(bnd <= 0 ){ return null; }
		
	generator opcode getOp(opcode op){ return op; }  
	generator int getStr(){ return ??(3); }
	generator int getConst(int c){return {| c|??|};}
	
	//generator for coreAST
	generator coreAST getPart(coreAST c1, coreAST c2, coreAST c3, int bnd) {
		coreAST var = new CVar(str=getStr());
		coreAST[5] arr;
		if(bnd <= 1){
			arr = {c1,c2,c3,var};
		}else{
			coreAST a =  getPart(c1,c2,c3, bnd-1);
			coreAST b =  getPart(c1,c2,c3, bnd-1);
			
			coreAST c4 = new ??(op=getOp(0),a=a,b=b,str=getConst(0));
			arr = {c1,c2,c3,var, c4};
		}
		return arr[??];
	}
	generator coreAST[3] desugarFields([int n],  sourceAST[n] fields){
		coreAST[3] out;
		int i=0;
		repeat(n){
			out[i] = desugar(fields[i],bnd-1); ++i;
		}
		return out;
	} 
	
	switch(s){
		case SNum: return new CNum(val = s.val);
		case STrue: return new CBool(v =1);
		case SFalse: return new CBool(v =0);
		case SVar: return new CVar(str =s.str);
		case SAssign: return new CAssign(str = s.str, a = desugar(s.a,bnd-1));
		case SLet: return new CLet(str = s.str, a = desugar(s.a,bnd-1), b= desugar(s.b,bnd-1));
		case SPrim1: return new CPrim1(op = s.op, a = desugar(s.a,bnd-1));
		case SPrim2 : return new CPrim2(op = s.op ,a = desugar(s.a,bnd-1), b=desugar(s.b,bnd-1));
		case SBetween:
		{
			coreAST[3] v = desugarFields( s.{sourceAST} );
			coreAST a = getPart(v[0], v[1], v[2], 1);
			coreAST b = getPart(v[0], v[1], v[2], 4);
			return new ??(op=getOp(0),a=a,b=b,str=getConst(0));
		}
		
	}
}
opcode intToOpcode (int op){
	if (op == 0) return new Oplus();
	if (op == 1) return new Ominus();
	if (op == 2) return new Oneg();
	if (op == 3) return new Oand();
	if (op == 4) return new Oor();
	if (op == 5) return new Onot();
	if (op == 6) return new Olt();
	return new Ogt();
}

sourceAST gOp([int n], int op, sourceAST[n] p){
	opcode o = intToOpcode(op);
	if(n==1){
		return new SPrim1( op= o, a = p[0]);
	}else{
		return new SPrim2(op=o, a=p[0], b=p[1]);
	}
} 

sourceAST gN(int n){
	return new SNum( val=n);
}

sourceAST gTrue(){
	return new STrue();
}
sourceAST gFalse(){
	return new SFalse();
}



sourceAST produce( int[50] encoding, ref int idx, int bnd, int sbnd){
	if(bnd <=0  || sbnd ==0){ 
		if(encoding[idx]==0){ ++idx; return new SNum(val=encoding[idx++]); }
        if(encoding[idx]==1){++idx; return new SVar(str = encoding[idx++]);}
        if(encoding[idx]==2){ ++idx; return new STrue(); }else{ ++idx; return new SFalse(); }          
     }
     if(encoding[idx] == 0){
     	idx++;
     	if(encoding[idx] == 0){ ++idx; return new SNum(val=encoding[idx++]); }
    	else{++idx; return new SVar(str = encoding[idx++]);}
     }
     else if(encoding[idx]==1){
        ++idx;
        if(encoding[idx] == 0){ ++idx;
        return gOp(2, encoding[idx++],{ produce(encoding, idx, bnd-1,sbnd/2),produce(encoding, idx, bnd-1,sbnd/2)}); 
        }
        else{
        	++idx; 
        	return new SBetween(a=produce(encoding, idx, bnd-1,sbnd/2),b=produce(encoding, idx, bnd-1,sbnd/2),c=produce(encoding, idx, bnd-1,sbnd/2));
        }
     }else if(encoding[idx]==2){
    	++idx;
    	return new SAssign(str = encoding[idx++],a= produce(encoding, idx, bnd-1,sbnd/2)); 
     }else
 	 if(encoding[idx]==3){
    	++idx;
    	return new SLet(str = encoding[idx++],a= produce(encoding, idx, bnd-1,sbnd/2),b = produce(encoding, idx, bnd-1,sbnd/2)); 
     }
     else{
    	++idx;
   		return null;
   	 }
}


sourceAST[size] smtStore;
sourceAST interpretSourceAST(sourceAST s, ref int idx, int bnd){
	if(s==null){
		return null;
	}
	if(bnd<0 ){
		return null;
	}
	switch(s){
		case SVar:
		{
			if (s.str >= idx) return null;
			sourceAST val = smtStore[s.str];
			if (val == null) return null;
			switch(val){
				case SNum: return val;
				case STrue: return val;
				case SFalse: return val;
				case SVar: return val;
				default: return null;
			}
		}
		case SAssign:
		{
			if(bnd <1 ) return null;
			else{
				sourceAST s_a = interpretSourceAST(s.a, idx,  bnd-1);
				if(s.str<0 || s.str>= size) return null;
				if (idx <= s.str) idx = s.str+1;
				if(s_a == null) return null;
				smtStore[s.str] = s_a;
				return s_a;
			}
		}
		case SPrim1:
		{
			if(bnd <1 ) return null;
			else{
			opcode op = s.op;
			if (op == null) return null;
			switch(op){
			case Oneg: {
				sourceAST s_a = interpretSourceAST(s.a,idx, bnd -1);
				if(s_a==null) return null;
				switch(s_a){
					case SNum: {return new SNum(val = (0-s_a.val));}
					default: {return null;}
				}
			}
			case Onot: {
				sourceAST s_a = interpretSourceAST(s.a,idx, bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case STrue:{ return new SFalse();}
					case SFalse:{ return new STrue();}
					default: {return null;}
				}	
			}
			default:{
				return null;
			}
			}
			}
		}
		
		case SPrim2:
		{
			if(bnd <1 ) return null;
			else{
			opcode op = s.op;
			if(op == null) return null;
			switch(op){
			case Oplus: {
				int a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx,  bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case SNum:{ a = s_a.val;}
					default:{ return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx,bnd -1);
				if(s_b==null) return null;
				switch(s_b){
					case SNum: {b = s_b.val;}
					default: {return null;}
				}
				return new SNum(val = a+b);
			}
			case Ominus: {
				int a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx,  bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case SNum: {a = s_a.val;}
					default: {return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx,bnd-1);
				if(s_b==null) return null;
				switch(s_b){
					case SNum: {b = s_b.val;}
					default: {return null;}
				}
				return new SNum(val = a-b);
			}
			case Oand: {
				bit a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx, bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case STrue: {a = 1;}
					case SFalse: {a = 0;}
					default: {return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx, bnd-1);
				if(s_b==null) return null;
				switch(s_b){
					case STrue:{ b = 1;}
					case SFalse:{ b = 0;}
					default: {return null;}
				}
				if (a&&b) return new STrue();
				else return new SFalse();
				
			}
			case Oor: {
				bit a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx,  bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case STrue: {a = 1;}
					case SFalse: {a = 0;}
					default: {return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx,  bnd-1);
				if(s_b==null) return null;
				switch(s_b){
					case STrue: {b = 1;}
					case SFalse:{ b = 0;}
					default: {return null;}
				}
				if(a||b) return new STrue();
				else return new SFalse();
				
			}
			case Ogt: {
				int a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx, bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case SNum: {a = s_a.val;}
					default: {return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx, bnd-1);
				if(s_b==null) return null;
				switch(s_b){
					case SNum: {b = s_b.val;}
					default: {return null;}
				}
				if(a>b) return new STrue();
				else return new SFalse();
				
			}
			case Olt: {
				int a, b;
				sourceAST s_a = interpretSourceAST(s.a,idx,  bnd-1);
				if(s_a==null) return null;
				switch(s_a){
					case SNum:{ a = s_a.val;}
					default: {return null;}
				}
				sourceAST s_b = interpretSourceAST(s.b,idx,bnd-1);
				if(s_b==null) return null;
				switch(s_b){
					case SNum: {b = s_b.val;}
					default: {return null;}
				}
				if(a<b) return new STrue();
				else return new SFalse();
				
			}
			default:{
				return null;	
			}
			}
			}				
		}
		case SBetween:
		{
			
			if(bnd <1 ) return null;
			else{
			int a, b, c;
			sourceAST s_a = interpretSourceAST(s.a,idx,  bnd-1);
			
			if(s_a==null) return null;
			switch(s_a){
				case SNum: {a = s_a.val;}
				default: {return null;}
			}
			sourceAST s_b = interpretSourceAST(s.b,idx,  bnd-1);
			if(s_b==null) return null;
			switch(s_b){
				case SNum:{ b = s_b.val;}
				default: {return null;}
			}
			sourceAST s_c = interpretSourceAST(s.c,idx, bnd-1);
			if(s_c==null) return null;
			switch(s_c){
				case SNum: {c = s_c.val;}
				default: {return null;}
			}
			if(a<b&&b<c) return new STrue();
			else return new SFalse();
			}
			
		}	
		
		case SLet:
		{
		if(bnd <1) return null;
		else{
		
		sourceAST s_a = interpretSourceAST(s.a, idx, bnd-1);
		if(s.str<0 || s.str>=size) return null;
		if (idx <= s.str) idx = s.str+1;
		if(s_a == null) return null;
		smtStore[s.str] = s_a;
		return interpretSourceAST(s.b, idx, bnd-1);
		}
		}
		default: {return s;}
		
		
		
	}
	
	
}


coreAST[size] cmtStore;
@DontCombine("")
coreAST interpretCoreAST(coreAST s, int bnd){
	if(bnd<0){
		return null;
	}
	coreAST sa = null;
	coreAST sb = null;
	switch(s){
		case CAssign: {sa = s.a;}
		case CPrim1: {sa= s.a;}
		case CPrim2: {sa = s.a; sb = s.b;}
		case CLet: {sa= s.a; sb = s.b;}
		default:{}
		
	}
	coreAST s_a = null;
	coreAST s_b = null;
	if(sa != null && bnd >=1){
		s_a = interpretCoreAST(sa, bnd-1);
		assert(s_a != null);
	}
	switch(s){
		case CLet:{if(s.str<0 || s.str>= size) return null;
		assert s_a != null;
		cmtStore[s.str] = s_a;
		}
		
		default:{}	
	}
	if(sb != null && bnd >=1){
		s_b =  interpretCoreAST(sb,  bnd-1);
		assert(s_b != null);
	}
	
	switch(s){
		case CVar:
		{
			coreAST val = cmtStore[s.str];
			assert(val != null);
			if(val == null) {  return null;}
			switch(val){
				case CNum: return val;
				case CBool: return val;
				case CVar: return val;
				default: {  assert false; return null;}
			}
		}
		case CAssign:
		{
			if(bnd <1){  return null;}
			else{
			if(s.str<0 || s.str>= size) {assert false; return null;}
			assert(s_a != null);
			cmtStore[s.str] = s_a;
			return s_a;
			}
		}
		case CPrim1:
		{
			if(bnd <1 ) return null;
			else{
			opcode op = s.op;
			if (op == null ) return null;
			switch(op){
			case Oneg: {
				//coreAST s_a = interpretCoreAST(s.a,idx, bnd-1);
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CNum: {return new CNum(val = (0-s_a.val));}
					default: { assert false; return null;}
				}
			}
			case Onot: {
				//coreAST s_a = interpretCoreAST(s.a,idx, bnd-1);
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CBool:{ return new CBool( v = (!s_a.v));}
					default: {assert false; return null;}
				}	
			}
			default:{
				return null;
			}
			}
			}
		}
		
		case CPrim2:
		{
			if(bnd <1 ) return null;
			else{
				opcode op = s.op;
				if (op == null) return null;
				switch(op) {
				case Oplus: {
				int a, b;
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CNum: {a = s_a.val;}
					default: {assert false; return null;}
				}
				if(s_b==null) {assert false; return null;}
				switch(s_b){
					case CNum: {b = s_b.val;}
					default: {assert false; return null;}
				}
				return new CNum(val = a+b);
				}
			case Ominus: {
				int a, b;
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CNum: {a = s_a.val;}
					default: {assert false; return null;}
				}
				if(s_b==null) {assert false ;return null;}
				switch(s_b){
					case CNum: {b = s_b.val;}
					default: {assert false; return null;}
				}
				return new CNum(val = a-b);
			}
			case Oand: {
				bit a, b;
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CBool:{ a = s_a.v;}
					default:{ assert false; return null;}
				}
				if(s_b==null){assert false; return null;}
				switch(s_b){
					case CBool:{ b = s_b.v;}
					default: {assert false; return null;}
				}
				return new CBool(v = a&&b);
			}
			case Oor: {
				bit a, b;
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CBool: {a = s_a.v;}
					default: {assert false; return null;}
				}
				if(s_b==null) {assert false; return null;}
				switch(s_b){
					case CBool: {b = s_b.v;}
					default: {assert false; return null;}
				}
				return new CBool(v = a||b);
			}
			case Ogt: {
				int a, b;
				if(s_a==null){assert false; return null;}
				switch(s_a){
					case CNum: {a = s_a.val;}
					default: {assert false; return null;}
				}
				if(s_b==null) {assert false; return null;}
				switch(s_b){
					case CNum:{ b = s_b.val;}
					default: {assert false; return null;}
				}
				return new CBool(v = a>b);
			}
			case Olt:{
				int a, b;
				if(s_a==null) {assert false; return null;}
				switch(s_a){
					case CNum: {a = s_a.val;}
					default: {assert false; return null;}
				}
				if(s_b==null) {assert false; return null;}
				switch(s_b){
					case CNum:{ b = s_b.val;}
					default: {assert false; return null;}
				}
				return new CBool(v = a<b);
			}
			default: {
				assert false;
				return null;	
			}
			}	
			}			
		}
		case CLet:
		{
		
		if(bnd <1) {assert false; return null;}
		else{
		
		return s_b;
		}
		}
		
		default: return s;
		
		
		
	}
	
	
}

bit equals(sourceAST c1 ,coreAST c2){
	if(c1== null) return true;
	if(c2 == null) return false;
	
	switch(c1){
		case SNum:
		{
			switch(c2){
				case CNum: return c1.val == c2.val;
				default: {assert false; return false;}
			}
		}
		case STrue:
		{
			switch(c2){
				case CBool:return c2.v==1;
				default: {assert false; return false;}
			}
		}
		case SFalse:
		{
			switch(c2){
				case CBool: return c2.v==0;
				default: {assert false; return false;}
			}
		}
		case SVar:
		{
			switch(c2){
				case CVar: {assert false; return c1.str == c2.str;}
				default: {assert false; return false;}
			}
		}
		default: {assert false; return false;}
	}
	
	
}

harness void main2(){
	sourceAST s =   new SBetween(a = new SLet(str = 1,a= gN(1) ,b =gN(1)), b = new SAssign(str = 1, a= new SPrim2(op = new Oplus(), a = new SVar(str = 1), b= new SNum(val = 1))),c = gN(3));	
	
	for(int i = 0; i < size; i++){
		smtStore[i] = null;
	}
	int zz = 0;
	sourceAST c1 = interpretSourceAST(s,zz,3);
	
	if(c1 != null){
		coreAST c2  = desugar(s,5);
		//CLet c = (CLet)c2;
		for(int i = 0; i < size; i++){
			cmtStore[i] = null;
		}
		coreAST c3 = interpretCoreAST(c2,4);
		assert(c3!=null);
		assert(equals(c1,c3));
	}
}
harness void main3(int[50] arr) {
	int idx =0;
	sourceAST s =  new SBetween(a =produce( arr, idx, 1, 2), b = produce( arr, idx, 1,2),c =produce( arr, idx, 0, 2));
	
	for(int i = 0; i < size; i++){
		smtStore[i] = null;
	}
	int z =0;
	sourceAST c1 = interpretSourceAST(s,z,2);
	if(c1 != null){
		coreAST c2  = desugar(s,3);
		for(int i = 0; i < size; i++){
			cmtStore[i] = null;
		}
		coreAST c3 = interpretCoreAST(c2,4);
		assert(c3!=null);
		assert(equals(c1,c3));
	}	
	
}
