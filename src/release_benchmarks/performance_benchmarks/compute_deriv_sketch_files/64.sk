int C=5;
int nchanges = 0;
bit choiceAssign0 = 0;
bit choiceAssign1 = 0;
bit choiceAssign2 = 0;
bit choiceAssign3 = 0;
bit choiceAssign4 = 0;
bit choiceAssign5 = 0;
bit choiceAssign6 = 0;
bit choiceAssign7 = 0;
bit choiceAssign8 = 0;
bit choiceAssign9 = 0;
bit choiceAssign10 = 0;
bit choiceAssign11 = 0;
bit choiceAssign12 = 0;
bit choiceAssign13 = 0;
bit choiceAssign14 = 0;
bit choiceAssign15 = 0;
bit choiceAssign16 = 0;
bit choiceAssign17 = 0;
bit choiceAssign18 = 0;
bit choiceAssign19 = 0;
bit choiceAssign20 = 0;
bit choiceAssign21 = 0;
bit choiceOperator0 = 0;
bit choiceOperator1 = 0;
bit choiceOperator2 = 0;
bit choiceOperator3 = 0;
bit choiceOperator4 = 0;
bit choiceOperator5 = 0;
bit choiceOperator6 = 0;
bit choiceOperator7 = 0;
bit choiceOperator8 = 0;
bit choiceOperator9 = 0;
bit choiceOperator10 = 0;
bit choiceOperator11 = 0;
bit choiceOperator12 = 0;
bit choiceOperator13 = 0;
bit choiceOperator14 = 0;
bit choiceOperator15 = 0;
bit choiceOperator16 = 0;
bit choiceOperator17 = 0;
bit choiceOperator18 = 0;
bit choiceOperator19 = 0;
bit choiceOperator20 = 0;
bit choiceOperator21 = 0;
bit choiceCompOperator0 = 0;
bit choiceCompOperator1 = 0;
bit choiceCompOperator2 = 0;
bit choiceCompOperator3 = 0;
bit choiceCompOperator4 = 0;
bit choiceCompOperator5 = 0;
bit choiceCompOperator6 = 0;
bit choiceCompOperator7 = 0;
bit choiceCompOperator8 = 0;
bit choiceCompOperator9 = 0;
bit choiceCompOperator10 = 0;
bit choiceCompOperator11 = 0;
bit choiceCompOperator12 = 0;
bit choiceCompOperator13 = 0;
bit choiceInit0 = 0;
bit choiceInit1 = 0;
bit choiceInit2 = 0;
bit choiceInit3 = 0;
bit choiceInit4 = 0;
bit choiceInit5 = 0;
bit choiceInit6 = 0;
bit choiceInit7 = 0;
bit choiceInit8 = 0;
bit choiceInit9 = 0;
bit choiceInit10 = 0;
bit choiceInit11 = 0;
bit choiceInit12 = 0;
bit choiceInit13 = 0;
bit choiceInit14 = 0;
bit choiceInit15 = 0;
bit choiceInit16 = 0;
bit choiceInit17 = 0;
bit choiceInit18 = 0;
bit choiceInit19 = 0;
bit choiceInit20 = 0;
bit choiceInit21 = 0;
bit choiceInit22 = 0;
bit choiceInit23 = 0;
bit choiceInit24 = 0;
bit choiceInit25 = 0;
bit choiceInit26 = 0;
bit choiceInit27 = 0;
bit choiceInit28 = 0;
bit choiceInit29 = 0;
bit choiceInit30 = 0;
bit choiceInit31 = 0;
bit choiceInit32 = 0;
bit choiceLoopIter0 = 0;
bit choiceLoopIter1 = 0;
bit choiceLoopIter2 = 0;
bit choiceLoopIter3 = 0;
bit choiceLoopIter4 = 0;
bit choiceLoopIter5 = 0;
bit choiceLoopIter6 = 0;
bit choiceBaseCase0 = 0;
void calculateChanges(){
if(choiceAssign0) nchanges = nchanges + 1;
if(choiceAssign1) nchanges = nchanges + 1;
if(choiceAssign2) nchanges = nchanges + 1;
if(choiceAssign3) nchanges = nchanges + 1;
if(choiceAssign4) nchanges = nchanges + 1;
if(choiceAssign5) nchanges = nchanges + 1;
if(choiceAssign6) nchanges = nchanges + 1;
if(choiceAssign7) nchanges = nchanges + 1;
if(choiceAssign8) nchanges = nchanges + 1;
if(choiceAssign9) nchanges = nchanges + 1;
if(choiceAssign10) nchanges = nchanges + 1;
if(choiceAssign11) nchanges = nchanges + 1;
if(choiceAssign12) nchanges = nchanges + 1;
if(choiceAssign13) nchanges = nchanges + 1;
if(choiceAssign14) nchanges = nchanges + 1;
if(choiceAssign15) nchanges = nchanges + 1;
if(choiceAssign16) nchanges = nchanges + 1;
if(choiceAssign17) nchanges = nchanges + 1;
if(choiceAssign18) nchanges = nchanges + 1;
if(choiceAssign19) nchanges = nchanges + 1;
if(choiceAssign20) nchanges = nchanges + 1;
if(choiceAssign21) nchanges = nchanges + 1;
if(choiceOperator0) nchanges = nchanges + 1;
if(choiceOperator1) nchanges = nchanges + 1;
if(choiceOperator2) nchanges = nchanges + 1;
if(choiceOperator3) nchanges = nchanges + 1;
if(choiceOperator4) nchanges = nchanges + 1;
if(choiceOperator5) nchanges = nchanges + 1;
if(choiceOperator6) nchanges = nchanges + 1;
if(choiceOperator7) nchanges = nchanges + 1;
if(choiceOperator8) nchanges = nchanges + 1;
if(choiceOperator9) nchanges = nchanges + 1;
if(choiceOperator10) nchanges = nchanges + 1;
if(choiceOperator11) nchanges = nchanges + 1;
if(choiceOperator12) nchanges = nchanges + 1;
if(choiceOperator13) nchanges = nchanges + 1;
if(choiceOperator14) nchanges = nchanges + 1;
if(choiceOperator15) nchanges = nchanges + 1;
if(choiceOperator16) nchanges = nchanges + 1;
if(choiceOperator17) nchanges = nchanges + 1;
if(choiceOperator18) nchanges = nchanges + 1;
if(choiceOperator19) nchanges = nchanges + 1;
if(choiceOperator20) nchanges = nchanges + 1;
if(choiceOperator21) nchanges = nchanges + 1;
if(choiceCompOperator0) nchanges = nchanges + 1;
if(choiceCompOperator1) nchanges = nchanges + 1;
if(choiceCompOperator2) nchanges = nchanges + 1;
if(choiceCompOperator3) nchanges = nchanges + 1;
if(choiceCompOperator4) nchanges = nchanges + 1;
if(choiceCompOperator5) nchanges = nchanges + 1;
if(choiceCompOperator6) nchanges = nchanges + 1;
if(choiceCompOperator7) nchanges = nchanges + 1;
if(choiceCompOperator8) nchanges = nchanges + 1;
if(choiceCompOperator9) nchanges = nchanges + 1;
if(choiceCompOperator10) nchanges = nchanges + 1;
if(choiceCompOperator11) nchanges = nchanges + 1;
if(choiceCompOperator12) nchanges = nchanges + 1;
if(choiceCompOperator13) nchanges = nchanges + 1;
if(choiceInit0) nchanges = nchanges + 1;
if(choiceInit1) nchanges = nchanges + 1;
if(choiceInit2) nchanges = nchanges + 1;
if(choiceInit3) nchanges = nchanges + 1;
if(choiceInit4) nchanges = nchanges + 1;
if(choiceInit5) nchanges = nchanges + 1;
if(choiceInit6) nchanges = nchanges + 1;
if(choiceInit7) nchanges = nchanges + 1;
if(choiceInit8) nchanges = nchanges + 1;
if(choiceInit9) nchanges = nchanges + 1;
if(choiceInit10) nchanges = nchanges + 1;
if(choiceInit11) nchanges = nchanges + 1;
if(choiceInit12) nchanges = nchanges + 1;
if(choiceInit13) nchanges = nchanges + 1;
if(choiceInit14) nchanges = nchanges + 1;
if(choiceInit15) nchanges = nchanges + 1;
if(choiceInit16) nchanges = nchanges + 1;
if(choiceInit17) nchanges = nchanges + 1;
if(choiceInit18) nchanges = nchanges + 1;
if(choiceInit19) nchanges = nchanges + 1;
if(choiceInit20) nchanges = nchanges + 1;
if(choiceInit21) nchanges = nchanges + 1;
if(choiceInit22) nchanges = nchanges + 1;
if(choiceInit23) nchanges = nchanges + 1;
if(choiceInit24) nchanges = nchanges + 1;
if(choiceInit25) nchanges = nchanges + 1;
if(choiceInit26) nchanges = nchanges + 1;
if(choiceInit27) nchanges = nchanges + 1;
if(choiceInit28) nchanges = nchanges + 1;
if(choiceInit29) nchanges = nchanges + 1;
if(choiceInit30) nchanges = nchanges + 1;
if(choiceInit31) nchanges = nchanges + 1;
if(choiceInit32) nchanges = nchanges + 1;
if(choiceLoopIter0) nchanges = nchanges + 1;
if(choiceLoopIter1) nchanges = nchanges + 1;
if(choiceLoopIter2) nchanges = nchanges + 1;
if(choiceLoopIter3) nchanges = nchanges + 1;
if(choiceLoopIter4) nchanges = nchanges + 1;
if(choiceLoopIter5) nchanges = nchanges + 1;
if(choiceLoopIter6) nchanges = nchanges + 1;
if(choiceBaseCase0) nchanges = nchanges + 1;
assert nchanges <= C;
}
MultiType fuzzAssign0(MultiType i){
if(!(??)) return i;
else{
choiceAssign0 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign1(MultiType i){
if(!(??)) return i;
else{
choiceAssign1 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign2(MultiType i){
if(!(??)) return i;
else{
choiceAssign2 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign3(MultiType i){
if(!(??)) return i;
else{
choiceAssign3 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign4(MultiType i){
if(!(??)) return i;
else{
choiceAssign4 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign5(MultiType i){
if(!(??)) return i;
else{
choiceAssign5 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign6(MultiType i){
if(!(??)) return i;
else{
choiceAssign6 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign7(MultiType i){
if(!(??)) return i;
else{
choiceAssign7 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign8(MultiType i){
if(!(??)) return i;
else{
choiceAssign8 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign9(MultiType i){
if(!(??)) return i;
else{
choiceAssign9 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign10(MultiType i){
if(!(??)) return i;
else{
choiceAssign10 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign11(MultiType i){
if(!(??)) return i;
else{
choiceAssign11 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign12(MultiType i){
if(!(??)) return i;
else{
choiceAssign12 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign13(MultiType i){
if(!(??)) return i;
else{
choiceAssign13 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign14(MultiType i){
if(!(??)) return i;
else{
choiceAssign14 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign15(MultiType i){
if(!(??)) return i;
else{
choiceAssign15 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign16(MultiType i){
if(!(??)) return i;
else{
choiceAssign16 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign17(MultiType i){
if(!(??)) return i;
else{
choiceAssign17 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign18(MultiType i){
if(!(??)) return i;
else{
choiceAssign18 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign19(MultiType i){
if(!(??)) return i;
else{
choiceAssign19 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign20(MultiType i){
if(!(??)) return i;
else{
choiceAssign20 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzAssign21(MultiType i){
if(!(??)) return i;
else{
choiceAssign21 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzOperator0(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator0 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator1(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator1 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator2(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator2 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator3(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator3 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator4(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator4 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator5(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator5 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator6(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator6 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator7(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator7 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator8(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator8 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator9(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator9 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator10(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator10 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator11(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator11 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator12(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator12 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator13(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator13 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator14(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator14 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator15(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator15 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator16(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator16 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator17(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator17 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator18(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator18 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator19(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator19 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator20(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator20 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
MultiType fuzzOperator21(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyBinOp(lhs, rhs, op);
else{
choiceOperator21 = 1;
if(??) return applyAddBinOp(lhs, rhs);
else if(??) return applySubBinOp(lhs, rhs);
else if(??) return applyMulBinOp(lhs, rhs);
}}
bit fuzzCompOperator0(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator0 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator1(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator1 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator2(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator2 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator3(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator3 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator4(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator4 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator5(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator5 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator6(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator6 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator7(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator7 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator8(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator8 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator9(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator9 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator10(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator10 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator11(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator11 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator12(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator12 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
bit fuzzCompOperator13(MultiType lhs, MultiType rhs, int op){
if(!(??)) return applyCompOp(lhs, rhs, op);
else{
choiceCompOperator13 = 1;
if(??) return applyEQCompOp(lhs, rhs);
else if(??) return applyNEQCompOp(lhs, rhs);
else if(??) return applyLTCompOp(lhs, rhs);
else if(??) return applyLTECompOp(lhs, rhs);
else if(??) return applyGTCompOp(lhs, rhs);
else if(??) return setTrue();
else if(??) return setFalse();
else return applyGTECompOp(lhs, rhs);
}}
MultiType fuzzInit0(MultiType i){
if(!(??)) return i;
else{
choiceInit0 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit1(MultiType i){
if(!(??)) return i;
else{
choiceInit1 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit2(MultiType i){
if(!(??)) return i;
else{
choiceInit2 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit3(MultiType i){
if(!(??)) return i;
else{
choiceInit3 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit4(MultiType i){
if(!(??)) return i;
else{
choiceInit4 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit5(MultiType i){
if(!(??)) return i;
else{
choiceInit5 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit6(MultiType i){
if(!(??)) return i;
else{
choiceInit6 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit7(MultiType i){
if(!(??)) return i;
else{
choiceInit7 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit8(MultiType i){
if(!(??)) return i;
else{
choiceInit8 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit9(MultiType i){
if(!(??)) return i;
else{
choiceInit9 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit10(MultiType i){
if(!(??)) return i;
else{
choiceInit10 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit11(MultiType i){
if(!(??)) return i;
else{
choiceInit11 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit12(MultiType i){
if(!(??)) return i;
else{
choiceInit12 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit13(MultiType i){
if(!(??)) return i;
else{
choiceInit13 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit14(MultiType i){
if(!(??)) return i;
else{
choiceInit14 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit15(MultiType i){
if(!(??)) return i;
else{
choiceInit15 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit16(MultiType i){
if(!(??)) return i;
else{
choiceInit16 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit17(MultiType i){
if(!(??)) return i;
else{
choiceInit17 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit18(MultiType i){
if(!(??)) return i;
else{
choiceInit18 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit19(MultiType i){
if(!(??)) return i;
else{
choiceInit19 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit20(MultiType i){
if(!(??)) return i;
else{
choiceInit20 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit21(MultiType i){
if(!(??)) return i;
else{
choiceInit21 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit22(MultiType i){
if(!(??)) return i;
else{
choiceInit22 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit23(MultiType i){
if(!(??)) return i;
else{
choiceInit23 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit24(MultiType i){
if(!(??)) return i;
else{
choiceInit24 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit25(MultiType i){
if(!(??)) return i;
else{
choiceInit25 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit26(MultiType i){
if(!(??)) return i;
else{
choiceInit26 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit27(MultiType i){
if(!(??)) return i;
else{
choiceInit27 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit28(MultiType i){
if(!(??)) return i;
else{
choiceInit28 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit29(MultiType i){
if(!(??)) return i;
else{
choiceInit29 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit30(MultiType i){
if(!(??)) return i;
else{
choiceInit30 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit31(MultiType i){
if(!(??)) return i;
else{
choiceInit31 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzInit32(MultiType i){
if(!(??)) return i;
else{
choiceInit32 = 1;
if(??) return incrementOne(i);
else if(??) return incrementTwo(i);
else if(??) return decrementOne(i);
else if(??) return decrementTwo(i);
else if(??) return setZero(i);
else return setOne(i);
}
}
MultiType fuzzLoopIter0(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter0 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter1(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter1 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter2(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter2 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter3(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter3 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter4(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter4 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter5(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter5 = 1;
return range1(i);
}
}
MultiType fuzzLoopIter6(MultiType i){
if(!(??)) return i;
else{
choiceLoopIter6 = 1;
return range1(i);
}
}
void fuzzBaseCase0(ref bit x){
if(??) {choiceBaseCase0 = 1;
x = 1;
}
else x = 0;
}


MultiType evaluate_poly(MultiType poly,MultiType x){
assignMT(poly, fuzzAssign0(map(fuzzInit0(intTypeMT), fuzzInit1(poly))));
void body0(MultiType i){
if((fuzzCompOperator0(i, new MultiType(val=0,flag=INTEGER), EQ_COMP))){
MultiType y;
assignMT(y, fuzzAssign1(subscriptMTi(poly, new MultiType(val=0,flag=INTEGER))));
}
if((fuzzCompOperator1(new MultiType(val=0,flag=INTEGER), i, LT_COMP))){
MultiType y;
assignMT(y, fuzzAssign2(fuzzOperator0((y), (fuzzOperator1((subscriptMTi(poly, i)), (fuzzOperator2((x), (i), POW_OP)), MUL_OP)), ADD_OP)));
}
}
foreach(body0, fuzzLoopIter0(range2(fuzzInit2(new MultiType(val=0,flag=INTEGER)), fuzzInit3(len(fuzzInit4(poly))))));
return y;
}

MultiType compute_deriv(MultiType poly){
bit addBaseCase0;
fuzzBaseCase0(addBaseCase0);
if(addBaseCase0) {if (poly.lst.len <= 1) return new MultiType(flag = LIST, lst = new MTList(len = 1, listValues = {new MultiType(val =0, flag = INTEGER)}));}
assignMT(poly, fuzzAssign3(map(fuzzInit5(intTypeMT), fuzzInit6(poly))));
popList(poly, new MultiType(val=0,flag=INTEGER));
void body1(MultiType i){
assignMTArray(poly, i, fuzzAssign4(fuzzOperator3((subscriptMTi(poly, i)), (fuzzOperator4((i), (new MultiType(val=1,flag=INTEGER)), ADD_OP)), MUL_OP)));
}
foreach(body1, fuzzLoopIter1(range2(fuzzInit7(new MultiType(val=0,flag=INTEGER)), fuzzInit8(len(fuzzInit9(poly))))));
return poly;
}

MultiType compute_root(MultiType poly,MultiType x_0,MultiType epsilon){
assignMT(poly, fuzzAssign5(map(fuzzInit10(intTypeMT), fuzzInit11(poly))));
MultiType der_poly;
assignMT(der_poly, fuzzAssign6(subscriptMTl(poly, new MultiType(val=1,flag=INTEGER))));
assignMT(der_poly, fuzzAssign7(map(fuzzInit12(intTypeMT), fuzzInit13(der_poly))));
void body2(MultiType i){
assignMTArray(der_poly, i, fuzzAssign8(fuzzOperator5((subscriptMTi(der_poly, i)), (fuzzOperator6((i), (new MultiType(val=1,flag=INTEGER)), ADD_OP)), MUL_OP)));
}
foreach(body2, fuzzLoopIter2(range2(fuzzInit14(new MultiType(val=0,flag=INTEGER)), fuzzInit15(len(fuzzInit16(der_poly))))));
void body3(MultiType i){
if((fuzzCompOperator2(i, new MultiType(val=0,flag=INTEGER), EQ_COMP))){
MultiType y;
assignMT(y, fuzzAssign9(subscriptMTi(poly, new MultiType(val=0,flag=INTEGER))));
}
if((fuzzCompOperator3(new MultiType(val=0,flag=INTEGER), i, LT_COMP))){
MultiType y;
assignMT(y, fuzzAssign10(fuzzOperator7((y), (fuzzOperator8((subscriptMTi(poly, i)), (fuzzOperator9((x_0), (i), POW_OP)), MUL_OP)), ADD_OP)));
}
}
foreach(body3, fuzzLoopIter3(range2(fuzzInit17(new MultiType(val=0,flag=INTEGER)), fuzzInit18(len(fuzzInit19(poly))))));
void body4(MultiType i){
if((fuzzCompOperator4(i, new MultiType(val=0,flag=INTEGER), EQ_COMP))){
MultiType der_y;
assignMT(der_y, fuzzAssign11(subscriptMTi(der_poly, new MultiType(val=0,flag=INTEGER))));
}
if((fuzzCompOperator5(new MultiType(val=0,flag=INTEGER), i, LT_COMP))){
MultiType der_y;
assignMT(der_y, fuzzAssign12(fuzzOperator10((der_y), (fuzzOperator11((subscriptMTi(der_poly, i)), (fuzzOperator12((x_0), (i), POW_OP)), MUL_OP)), ADD_OP)));
}
}
foreach(body4, fuzzLoopIter4(range2(fuzzInit20(new MultiType(val=0,flag=INTEGER)), fuzzInit21(len(fuzzInit22(der_poly))))));
MultiType iterations;
assignMT(iterations, fuzzAssign13(new MultiType(val=1,flag=INTEGER)));
MultiType root;
assignMT(root, fuzzAssign14(new MultiType(lst=new MTList(len=2, listValues={x_0,iterations}), flag=LIST)));
if((fuzzCompOperator6(abs(fuzzInit23(y)), epsilon, LT_COMP))){
return root;
}
while((fuzzCompOperator7(abs(fuzzInit24(y)), epsilon, GTE_COMP))){
assignMT(x_0, fuzzAssign15(fuzzOperator13((x_0), (fuzzOperator14((y), (der_y), DIV_OP)), SUB_OP)));
void body5(MultiType i){
if((fuzzCompOperator8(i, new MultiType(val=0,flag=INTEGER), EQ_COMP))){
MultiType y;
assignMT(y, fuzzAssign16(subscriptMTi(poly, new MultiType(val=0,flag=INTEGER))));
}
if((fuzzCompOperator9(new MultiType(val=0,flag=INTEGER), i, LT_COMP))){
MultiType y;
assignMT(y, fuzzAssign17(fuzzOperator15((y), (fuzzOperator16((subscriptMTi(poly, i)), (fuzzOperator17((x_0), (i), POW_OP)), MUL_OP)), ADD_OP)));
}
}
foreach(body5, fuzzLoopIter5(range2(fuzzInit25(new MultiType(val=0,flag=INTEGER)), fuzzInit26(len(fuzzInit27(poly))))));
assignMT(iterations, fuzzAssign18(fuzzOperator18((iterations), (new MultiType(val=1,flag=INTEGER)), ADD_OP)));
assignMT(root, fuzzAssign19(new MultiType(lst=new MTList(len=2, listValues={x_0,iterations}), flag=LIST)));
if((fuzzCompOperator10(abs(fuzzInit28(y)), epsilon, GTE_COMP))){
void body6(MultiType i){
if((fuzzCompOperator11(i, new MultiType(val=0,flag=INTEGER), EQ_COMP))){
MultiType der_y;
assignMT(der_y, fuzzAssign20(subscriptMTi(der_poly, new MultiType(val=0,flag=INTEGER))));
}
if((fuzzCompOperator12(new MultiType(val=0,flag=INTEGER), i, LT_COMP))){
MultiType der_y;
assignMT(der_y, fuzzAssign21(fuzzOperator19((der_y), (fuzzOperator20((subscriptMTi(der_poly, i)), (fuzzOperator21((x_0), (i), POW_OP)), MUL_OP)), ADD_OP)));
}
}
foreach(body6, fuzzLoopIter6(range2(fuzzInit29(new MultiType(val=0,flag=INTEGER)), fuzzInit30(len(fuzzInit31(der_poly))))));
}
if((fuzzCompOperator13(abs(fuzzInit32(y)), epsilon, LT_COMP))){
return root;
}
}
}


MultiType compute_deriv_teacher(MultiType poly){
if((applyCompOp(len(poly), new MultiType(val=1,flag=INTEGER), LTE_COMP))){
return new MultiType(lst=new MTList(len=1, listValues={new MultiType(val=0,flag=INTEGER)}), flag=LIST);
}
MultiType result;
assignMT(result, new MultiType(lst=new MTList(len=0, listValues={}), flag=LIST));
void body0(MultiType i){
assignMT(result, applyBinOp(result, new MultiType(lst=new MTList(len=1, listValues={applyBinOp((i), (subscriptMTi(poly, i)), MUL_OP)}), flag=LIST), ADD_OP));
}
foreach(body0, range2(new MultiType(val=1,flag=INTEGER), len(poly)));
return result;
}


int INTEGER = 0;
int LIST = 1;
int STRING = 2;


int ADD_OP = 0;
int SUB_OP = 1;
int MUL_OP = 2;
int DIV_OP = 3;
int POW_OP = 4;
int MOD_OP = 5;

int USub = 0;
int UAdd = 1;
int UNot = 2;
int UInvert = 3;

int EQ_COMP = 0;
int NEQ_COMP = 1;
int LT_COMP = 2;
int LTE_COMP = 3;
int GT_COMP = 4;
int GTE_COMP = 5;

MultiType intTypeMT = new MultiType(val = 0, flag = INTEGER);
MultiType listTypeMT = new MultiType(flag = LIST, lst = new MTList(len = 0, listValues={}));
MultiType noneMT = new MultiType(val =0, flag = INTEGER);


struct MultiType{
  int val;
  int flag;
  MTList lst;
  MTDict dict;
}

  struct MTDict{
    KeyValuePair[len] kvpairs;
    int len;
  }

    struct KeyValuePair{
      MultiType Key;
      MultiType Value;
    }

struct MTList{
  int len;
  MultiType[len] listValues;
}

void foreach(fun body, MultiType lst){
  assert lst.flag == LIST;
  MTList ma = lst.lst;
  for(int i101=0; i101<ma.len; i101++){
    body(ma.listValues[i101]);
  }
}

MultiType range1(MultiType x){
  assert x.flag == INTEGER;
  int ub = x.val;
  MultiType[ub] A;
  for(int i=0; i<ub; ++i){
    A[i] = new MultiType(val=i, flag=INTEGER);
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=ub), flag=LIST);
  return m;
}

MultiType range2(MultiType x, MultiType y){
  assert x.flag == INTEGER;
  assert y.flag == INTEGER;
  int lb = x.val;
  int ub = y.val;
  int newLen = ub - lb;
  MultiType[newLen] A;
  for(int i=lb; i< ub; ++i){
    A[i-lb] = new MultiType(val=i, flag=INTEGER);
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=newLen), flag=LIST);
  return m;
}

MultiType range3(MultiType x, MultiType y, MultiType step){
  assert x.flag == INTEGER;
  assert y.flag == INTEGER;
  assert step.flag == INTEGER;
  int lb = x.val;
  int ub = y.val;
  int stepdiff = step.val;
  int newLen = 0;
  for(int i=lb; i<ub-lb; i=i+stepdiff)
    newLen = newLen + 1;
  int newLen1 = newLen;
  MultiType[newLen1] A;
  int count = 0;
  for(int i=lb; i< ub-lb; i=i+stepdiff){
    A[count] = new MultiType(val=i, flag=INTEGER);
    count = count + 1;
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=newLen), flag=LIST);
  return m;
}

MultiType len(MultiType x){
    assert x.flag == LIST;
    return new MultiType(val = x.lst.len, flag=INTEGER);
}


// x[i]
MultiType subscriptMTi(MultiType list, MultiType index){
  assert list.flag == LIST;
  assert index.flag == INTEGER;
  assert index.val < list.lst.len;
  return list.lst.listValues[index.val];
}

// x[:]
MultiType subscriptMT(MultiType list, MultiType index){
  assert list.flag == LIST;
  assert index.flag == INTEGER;
  return list;
}

// x[:4]
MultiType subscriptMTu(MultiType list, MultiType rightIndex){
  assert list.flag == LIST;
  assert rightIndex.flag == INTEGER;
  return new MultiType(lst= new MTList(listValues = list.lst.listValues[0:rightIndex.val], len=rightIndex.val), flag = LIST);
}


// x[1:]
MultiType subscriptMTl(MultiType list, MultiType leftIndex){
  assert list.flag == LIST;
  assert leftIndex.flag == INTEGER;
  assert leftIndex.val < list.lst.len;
  int newLen = list.lst.len - leftIndex.val;
  MultiType[newLen] newListValues;
  for(int i=leftIndex.val; i < list.lst.len; i++)
    newListValues[i-leftIndex.val] = list.lst.listValues[i];
  return new MultiType(lst= new MTList(listValues=newListValues, len=newLen), flag = LIST);
}

// x[i:j]
MultiType subscriptMTul(MultiType list, MultiType leftIndex, MultiType rightIndex){
  assert list.flag == LIST;
  assert leftIndex.flag == INTEGER;
  assert rightIndex.flag == INTEGER;
  int newLen = rightIndex.val - leftIndex.val;
  MultiType[newLen] newListValues;
  for(int i=leftIndex.val; i < rightIndex.val; i++)
    newListValues[i-leftIndex.val] = list.lst.listValues[i];
  return new MultiType(lst= new MTList(listValues=newListValues, len=newLen), flag = LIST);
}


// x < y, applyCompOp(x,y, LT_COMP)

bit applyCompOp(MultiType left, MultiType right, int compop){
  if(left.flag != right.flag) return 0;
  if(compop == EQ_COMP)
    return applyEQCompOp(left,right);
  else if(compop == NEQ_COMP)
    return applyNEQCompOp(left,right);
  else if(compop == LT_COMP)
    return applyLTCompOp(left,right);
  else if(compop == LTE_COMP)
    return applyLTECompOp(left,right);
  else if(compop == GT_COMP)
    return applyGTCompOp(left,right);
  else if(compop == GTE_COMP)
    return applyGTECompOp(left,right);
}


//-x, not y

MultiType applyUnaryOp(MultiType operand, int op){
  if(op == USub) return applyUnarySubOp(operand);
  else if(op == UAdd) return applyUnaryAddOp(operand);
  else if(op == UNot) return applyUnaryNotOp(operand);
}

MultiType applyUnarySubOp(MultiType operand){
  assert operand.flag == INTEGER;
  return new MultiType(flag = INTEGER, val = -operand.val);
}

MultiType applyUnaryAddOp(MultiType operand){
  assert operand.flag == INTEGER;
  return operand;
}



// x + y, x -y

MultiType applyBinOp(MultiType left, MultiType right, int op){
  if(op == ADD_OP) return applyAddBinOp(left, right);
  else if(op == SUB_OP) return applySubBinOp(left,right);
  else if(op == MUL_OP) return applyMulBinOp(left,right);
  else if(op == DIV_OP) return applyDivBinOp(left,right);
  else if(op == POW_OP) return applyPowBinOp(left,right);
  else if(op == MOD_OP) return applyModBinOp(left,right);
 
}



MultiType applyAddBinOp(MultiType left, MultiType right){
    assert left.flag == right.flag; // can add same types only
    if(left.flag == INTEGER){
      return new MultiType(val = (left.val + right.val), flag = INTEGER);
    }
    else if(left.flag == LIST){
      int newLen = left.lst.len + right.lst.len;
      MultiType[newLen] newListValues = left.lst.listValues;
      for(int i=0; i<right.lst.len; i++)
	newListValues[i+left.lst.len] = right.lst.listValues[i];
      return new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));
    }
}


MultiType applySubBinOp(MultiType left, MultiType right){
    assert left.flag == INTEGER; // python supports subtraction for only integers and floats
    assert right.flag == INTEGER;
    return new MultiType(val = left.val - right.val, flag = INTEGER);
}

MultiType applyMulBinOp(MultiType left, MultiType right){
  if(left.flag == INTEGER && right.flag == INTEGER) return applyMulBinOpInt(left, right);
  if(left.flag == LIST && right.flag == INTEGER) return applyMulBinOpList(left, right);
  if(left.flag == INTEGER && right.flag == LIST) return applyMulBinOpList(right, left);
  assert false;
}

MultiType applyMulBinOpInt(MultiType left, MultiType right){
    return new MultiType(val=intMul(left.val, right.val), flag = INTEGER);
}

MultiType applyMulBinOpList(MultiType left, MultiType right){
  if(right.val == 0) return new MultiType(flag = LIST, lst=new MTList(len = 0, listValues={}));
  int newLen = left.lst.len * right.val;
  MultiType[newLen] newListValues;
  int count = 0;
  for(int i = 0; i< newLen; i++){
    newListValues[i] = left.lst.listValues[count];
    count = count + 1;
    if(count == left.lst.len) count = 0;
  }
  return new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues = newListValues));
}


MultiType applyDivBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intDiv(left.val,right.val), flag = INTEGER);
}

MultiType applyPowBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intPow(left.val,right.val), flag = INTEGER);
}

MultiType applyModBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intMod(left.val,right.val), flag = INTEGER);
}


bit applyEQCompOp(MultiType left, MultiType right){
  if (left.flag != right.flag) return 0;
  if(left.flag == LIST) return applyEQCompOpList(left, right);
  if(left.flag == INTEGER) return applyEQCompOpInt(left,right);
  return 0;
}

bit applyEQCompOpList(MultiType left, MultiType right){
  if(left.lst.len != right.lst.len) return 0;
  for(int i =0; i<left.lst.len; i++)
    if(!applyEQCompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyEQCompOpInt(MultiType left, MultiType right){
  return left.val == right.val;
}

bit applyNEQCompOp(MultiType left, MultiType right){
  return !applyEQCompOp(left,right);
}


bit applyLTCompOp(MultiType left, MultiType right){
  if(left.flag == LIST) return applyLTCompOpList(left, right);
  if(left.flag == INTEGER) return applyLTCompOpInt(left,right);
  return 0;
}

bit applyLTCompOpList(MultiType left, MultiType right){
  for(int i =0; i<min(right.lst.len,left.lst.len); i++)
    if(!applyLTCompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyLTCompOpInt(MultiType left, MultiType right){
  return left.val < right.val;
}

bit applyLTECompOp(MultiType left, MultiType right){
  if(left.flag == LIST) return applyLTECompOpList(left, right);
  if(left.flag == INTEGER) return applyLTECompOpInt(left,right);
  return 0;
}

bit applyLTECompOpList(MultiType left, MultiType right){
  for(int i =0; i<min(right.lst.len,left.lst.len); i++)
    if(!applyLTECompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyLTECompOpInt(MultiType left, MultiType right){
  return left.val <= right.val;
}


bit applyGTCompOp(MultiType left, MultiType right){
  return !applyLTECompOp(left,right);
}

bit applyGTECompOp(MultiType left, MultiType right){
  return !applyLTCompOp(left,right);
}

bit setTrue(){
  return 1;
}

bit setFalse(){
  return 0;
}

MultiType incrementOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val + 1;
  //return x;
  return new MultiType(val=x.val+1, flag = INTEGER);
}

MultiType incrementTwo(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val + 2;
  //return x;
  return new MultiType(val=x.val+2, flag = INTEGER);
}

MultiType decrementOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val - 1;
  //return x;
  return new MultiType(val=x.val-1, flag = INTEGER);
}

MultiType decrementTwo(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val - 2;
  //return x;
  return new MultiType(val=x.val-2, flag = INTEGER);
}

MultiType setOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = 1;
  //return x;
  return new MultiType(val=1, flag = INTEGER);
}

MultiType setZero(MultiType x){
  assert x.flag == INTEGER;
  //x.val = 0;
  //return x;
  return new MultiType(val=0, flag = INTEGER);
}


int intMul(int x, int y){
  if(x>y) return intMul1(x,y);
  else return intMul1(y,x);
  //  return (x*y);
}

int intMul1(int x, int y);
int intDiv(int x, int y);
int intPow(int x, int y);
int intMod(int x, int y){
  return x%y;
}

void assignMT(ref MultiType lhs, MultiType rhs){
  lhs = rhs;
}

void assignMTArray(MultiType arrayName, MultiType index, MultiType rhs){
  assert arrayName.flag == LIST;
  assert index.flag == INTEGER;
  assert index.val < arrayName.lst.len;
  arrayName.lst.listValues[index.val] = rhs;
}

MultiType abs(MultiType x){
  assert x.flag == INTEGER;
  if(x.val < 0) x.val = -x.val;
  return x;
}


MultiType popList(ref MultiType left, MultiType index){
  MultiType result;
  assert left.flag == LIST;
  assert index.flag == INTEGER;
  assert left.lst.len > 0;
  int prevLen = left.lst.len;
  int removeIndex;
  if(index.val >= 0) removeIndex = index.val;
  else removeIndex = left.lst.len + index.val;
  
  assert removeIndex < left.lst.len && removeIndex >= 0;
  int newLen = left.lst.len-1;
  MultiType[newLen] newListValues;
  result = left.lst.listValues[removeIndex];  
  int count = 0;
  for(int i=0; i<left.lst.len; i++){
    if(i != removeIndex){
      newListValues[count] = left.lst.listValues[i];
      count = count + 1;
    }

  }
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues=newListValues));
  return result;
}

void appendList(ref MultiType left, MultiType right){
    assert left.flag == LIST; // can append to list only
    int newLen = left.lst.len + 1;
    MultiType[newLen] newListValues;
    for(int i=0; i<left.lst.len; i++)
      newListValues[i] = left.lst.listValues[i];
    newListValues[left.lst.len] = right;
    left = new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));

}

void extendList(ref MultiType left, MultiType right){
    assert left.flag == LIST;
    assert right.flag == LIST;
    int newLen = left.lst.len + right.lst.len;
    MultiType[newLen] newListValues = left.lst.listValues;
    for(int i=0; i<right.lst.len; i++)
      newListValues[i+left.lst.len] = right.lst.listValues[i];
    left = new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));
}

void insertList(ref MultiType left, MultiType index, MultiType right){
  assert left.flag == LIST;
  assert index.flag == INTEGER;
  int newLen = left.lst.len + 1;
  MultiType[newLen] newListValues;
  int midIndex = min(left.lst.len, index.val);
  for(int i=0; i<midIndex; i++)
    newListValues[i] = left.lst.listValues[i];
  newListValues[midIndex] = right;
  for(int i=midIndex+1; i<left.lst.len; i++)
    newListValues[i] = left.lst.listValues[i-1];
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues=newListValues));
}

MultiType indexList(ref MultiType left, MultiType value){
  MultiType result;
  assert left.flag == LIST;
  for(int i=0; i<left.lst.len; i++){
    if(applyEQCompOp(left.lst.listValues[i], value))
      return new MultiType(val = i, flag = INTEGER);
  }
  assert false;
}

void removeList(ref MultiType left, MultiType value){
  MultiType result;
  assert left.flag == LIST;
  assert left.lst.len > 0;
  int newLen = left.lst.len - 1;
  MultiType[newLen] newListValues;
  bit found = 0;
  int count = 0;
  for(int i=0; i<left.lst.len; i++){
    if(found == 0 && applyEQCompOp(left.lst.listValues[i], value))
      found = 1;
    else{
      newListValues[count] = left.lst.listValues[i];
      count = count + 1;
    }
  }
  assert found;
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues = newListValues));
}


MultiType getTypeMT(MultiType x){
  if(x.flag == INTEGER) return intTypeMT;
  if(x.flag == LIST) return listTypeMT;
  return intTypeMT;
}

MultiType unknownTypeMT(){
  if(??) return intTypeMT;
  else return listTypeMT;
}


int min(int a, int b){
  if(a>=b) return b;
  else return a;
}
pragma options "--bnd-inbits 2 --bnd-unroll-amnt 4 --bnd-arr-size 4";

MultiType createMTFromInt(int x){
  return new MultiType(val = x, flag=INTEGER);
}

MultiType createMTFromArray(int N, int[N] a){
  MultiType[N] lvalues;
  for(int i=0; i<N;i++)
    lvalues[i] = new MultiType(val=a[i], flag =INTEGER);
  return new MultiType(flag = LIST, lst = new MTList(len=N, listValues=lvalues));
}

int[N] computeArrayFromMT(int N, MultiType a){
  int[N] result = 0;
  assert a.flag == LIST;
  for(int i=0; i<a.lst.len; i++){
    assert a.lst.listValues[i].flag == INTEGER;
    result[i] = a.lst.listValues[i].val;
  }
  return result;
}

int[N] compute_deriv_teacher_driver(int N, int[N] poly){
  int[N] result = 0;
  if(N==0) return result;
  MultiType polyMT = createMTFromArray(N, poly);
  MultiType result1 = compute_deriv_teacher(polyMT);
  assert result1.flag == LIST;
  if(N==1) assert result1.lst.len == 1;
  else assert result1.lst.len == N-1;
  result = computeArrayFromMT(N, result1);
  return result;
}

int[N] compute_deriv_student_driver(int N, int[N] poly) implements compute_deriv_teacher_driver{
  int[N] result = 0;
  if(N==0) return result;
  MultiType polyMT = createMTFromArray(N, poly);
  MultiType result1 = compute_deriv(polyMT);
  assert result1.flag == LIST;
  if(N==1) assert result1.lst.len == 1;
  else assert result1.lst.len == N-1;
  result = computeArrayFromMT(N, result1);
  calculateChanges();
  return result;
}

