// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.2,
// (C) 2004-2008 Robert Grimm,
// on Tuesday, September 2, 2014 at 10:28:23 PM.
// Edit at your own risk.
// ===========================================================================

package sketch.compiler.parser;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import sketch.compiler.ast.core.FEContext;
import sketch.compiler.ast.core.FENode;
import sketch.compiler.ast.core.exprs.*;
import sketch.compiler.ast.core.exprs.regens.ExprAlt;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceBinary;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect.Select;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect.SelectChain;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect.SelectField;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect.SelectOrr;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceSelect.Selector;
import sketch.compiler.ast.core.exprs.regens.ExprChoiceUnary;
import sketch.compiler.ast.core.exprs.regens.ExprParen;
import sketch.compiler.ast.core.typs.TypeStructRef;
import xtc.parser.Column;
import xtc.parser.ParseError;
import xtc.parser.ParserBase;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.util.Pair;
@SuppressWarnings("deprecation")

/**
 * Packrat parser for grammar <code>sketch.compiler.parser.Regen</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.2, (C) 2004-2008 Robert Grimm.
 */
public final class Regen extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fExpr;
    Result fExpr$$Star1;
    Result fExprCond;
    Result fParamList;
    Result fParamList$$Star1;
    Result fExprNamed;
    Result fExprBin;
    Result fExprBin$$Star1;
    Result fExprPrefix;
    Result fExprPrefixNQ;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fExprPrimary;
    Result fExprPrimary$$Star1;
    Result fTerm;
    Result fInfixOp;
    Result fPrefixOp;
    Result fPostfixOp;
    Result fPostfixOpNQ;
    Result fSelector;
    Result fSelectorNQ;
    Result fSelect;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fSelChoice;
    Result fSelChoice$$Star1;
    Result fSelChain;
    Result fSelChain$$Star1;
    Result fSel;
    Result fVar;
    Result fInOp;
    Result fPreOp;
    Result fPostOp;
    Result fs;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fKeyword;
    Result fId;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class RegenColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Regen(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Regen(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new RegenColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Regen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRegen(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEOF(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpr) 
      yyColumn.chunk1.fExpr = pExpr$1(yyStart);
    return yyColumn.chunk1.fExpr;
  }

  /** Actually parse sketch.compiler.parser.Regen.Expr. */
  private Result pExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprCond(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expression> l = yyResult.semanticValue();

        for (Expression e : l)  yyValue = new ExprAlt (yyValue, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal sketch.compiler.parser.Regen.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpr$$Star1) 
      yyColumn.chunk1.fExpr$$Star1 = pExpr$$Star1$1(yyStart);
    return yyColumn.chunk1.fExpr$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.Expr$$Star1. */
  private Result pExpr$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pExprCond(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression v$el$1 = yyResult.semanticValue();

        yyResult = pExpr$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expression> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Expression>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprCond.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprCond(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprCond) 
      yyColumn.chunk1.fExprCond = pExprCond$1(yyStart);
    return yyColumn.chunk1.fExprCond;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprCond. */
  private Result pExprCond$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprBin(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression b = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = ps(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pExprCond(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression c = yyResult.semanticValue();

              yyValue = new ExprTernary ("?:", a, b, c);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pExprBinNoQues(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression b = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = ps(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pExprCond(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression c = yyResult.semanticValue();

              yyValue = new ExprTernary ("?:", a, b, c);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pExprBin(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprNew.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprNew(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("new")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pID(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String structName = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('(' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pParamList(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<ExprNamedParam> l = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyResult.index + 1;

              TypeStructRef t = new TypeStructRef(structName, false);
                            yyValue = new ExprNew((FENode) null, t, l, false);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("??")) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('(' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pParamList(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<ExprNamedParam> l = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyResult.index + 1;

                            yyValue = new ExprNew((FENode) null, null, l, true);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'??' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("expr new expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ParamList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamList(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParamList) 
      yyColumn.chunk1.fParamList = pParamList$1(yyStart);
    return yyColumn.chunk1.fParamList;
  }

  /** Actually parse sketch.compiler.parser.Regen.ParamList. */
  private Result pParamList$1(final int yyStart) throws IOException {
    Result               yyResult;
    List<ExprNamedParam> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprNamed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprNamedParam e1st = yyResult.semanticValue();

      yyResult = pParamList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ExprNamedParam> l = yyResult.semanticValue();

        List<ExprNamedParam> paramList = new ArrayList<ExprNamedParam>();
        paramList.add(e1st);
        for (ExprNamedParam e: l) {
          paramList.add(e);
        }
        yyValue = paramList;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new ArrayList<ExprNamedParam>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * sketch.compiler.parser.Regen.ParamList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamList$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParamList$$Star1) 
      yyColumn.chunk1.fParamList$$Star1 = pParamList$$Star1$1(yyStart);
    return yyColumn.chunk1.fParamList$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.ParamList$$Star1. */
  private Result pParamList$$Star1$1(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    Pair<ExprNamedParam> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pExprNamed(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprNamedParam v$el$1 = yyResult.semanticValue();

        yyResult = pParamList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<ExprNamedParam> v$2 = yyResult.semanticValue();

          yyValue = new Pair<ExprNamedParam>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprNamed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprNamed(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprNamed) 
      yyColumn.chunk1.fExprNamed = pExprNamed$1(yyStart);
    return yyColumn.chunk1.fExprNamed;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprNamed. */
  private Result pExprNamed$1(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    ExprNamedParam yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String fieldName = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('=' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pExpr(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression right = yyResult.semanticValue();

          yyValue = new ExprNamedParam((FENode) null, fieldName, right);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprFuncInvok.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprFuncInvok(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String funcName = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pArgList(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expression> l = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyResult.index + 1;

                        yyValue = new ExprFunCall((FENode) null, funcName, l, null);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgList(final int yyStart) throws IOException {
    int              yyC;
    int              yyIndex;
    Result           yyResult;
    int              yyBase;
    int              yyRepetition1;
    Pair<Expression> yyRepValue1;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression e1st = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if (',' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Expression v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Expression>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<Expression> l = yyRepValue1.reverse();

        LinkedList<Expression> argList = new LinkedList<Expression>();
        argList.add(e1st);
        for (Expression e : l)
        argList.add(e);
        yyValue = argList;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Alternative 2.

    yyValue = new LinkedList<Expression>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprBin.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprBin) 
      yyColumn.chunk1.fExprBin = pExprBin$1(yyStart);
    return yyColumn.chunk1.fExprBin;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprBin. */
  private Result pExprBin$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExprBin$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Object> l = yyResult.semanticValue();

        yyValue = binExpr (yyValue, l.list ());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * sketch.compiler.parser.Regen.ExprBin$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression r = yyResult.semanticValue();

        yyValue = new P<BI,Expression>(ops, r);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal sketch.compiler.parser.Regen.ExprBin$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprBin$$Star1) 
      yyColumn.chunk1.fExprBin$$Star1 = pExprBin$$Star1$1(yyStart);
    return yyColumn.chunk1.fExprBin$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprBin$$Star1. */
  private Result pExprBin$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Object> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprBin$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Object v$el$1 = yyResult.semanticValue();

      yyResult = pExprBin$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Object> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Object>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprBinNoQues.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBinNoQues(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    Expression   yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pExprBinNoQues$$Choice1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Object v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Object>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for l.
        Pair<Object> l = yyRepValue1.reverse();

        yyResult = pInfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI ops = yyResult.semanticValue();

          yyResult = pExprPrefixNQ(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression r = yyResult.semanticValue();

            yyValue = new ExprChoiceBinary (yyValue, ops.i, r);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for l.
    }

    // Alternative 2.

    yyResult = pExprPrefixNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * sketch.compiler.parser.Regen.ExprBinNoQues$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBinNoQues$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression r = yyResult.semanticValue();

        yyPredResult = pInfixOp(yyResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pExprPrefixNQ(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = new P<BI,Expression>(ops, r);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrefix(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrefix) 
      yyColumn.chunk1.fExprPrefix = pExprPrefix$1(yyStart);
    return yyColumn.chunk1.fExprPrefix;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprPrefix. */
  private Result pExprPrefix$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrefixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyValue = new ExprChoiceUnary (ops.i, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pExprPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPrefixNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrefixNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrefixNQ) 
      yyColumn.chunk1.fExprPrefixNQ = pExprPrefixNQ$1(yyStart);
    return yyColumn.chunk1.fExprPrefixNQ;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprPrefixNQ. */
  private Result pExprPrefixNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrefixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefixNQ(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyValue = new ExprChoiceUnary (ops.i, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pExprPostfixNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPostfix(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          BI v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI ops : l)  yyValue = new ExprChoiceUnary (ops.i, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPostfixNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPostfixNQ(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          BI v$el$2 = yyResult.semanticValue();

          yyPredResult = pPostfixOpNQ(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$2, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI ops : l)  yyValue = new ExprChoiceUnary (ops.i, yyValue);

        yyResult = pPostfixOpNQ(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI ops = yyResult.semanticValue();

          yyValue = new ExprChoiceUnary (ops.i, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for l.
    }

    // Alternative 2.

    yyResult = pExprPrimaryNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimary(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExprPrimary) 
      yyColumn.chunk2.fExprPrimary = pExprPrimary$1(yyStart);
    return yyColumn.chunk2.fExprPrimary;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprPrimary. */
  private Result pExprPrimary$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExprPrimary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Selector> l = yyResult.semanticValue();

        for (Selector s : l)  yyValue = new ExprChoiceSelect (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * sketch.compiler.parser.Regen.ExprPrimary$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimary$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExprPrimary$$Star1) 
      yyColumn.chunk2.fExprPrimary$$Star1 = pExprPrimary$$Star1$1(yyStart);
    return yyColumn.chunk2.fExprPrimary$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.ExprPrimary$$Star1. */
  private Result pExprPrimary$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Selector> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Selector v$el$1 = yyResult.semanticValue();

      yyResult = pExprPrimary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Selector> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Selector>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ExprPrimaryNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimaryNQ(final int yyStart) throws IOException {
    Result         yyResult;
    Result         yyPredResult;
    int            yyRepetition1;
    Pair<Selector> yyRepValue1;
    Expression     yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSelector(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Selector v$el$1 = yyResult.semanticValue();

          yyPredResult = pSelectorNQ(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Selector>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for l.
        Pair<Selector> l = yyRepValue1.reverse();

        yyResult = pSelectorNQ(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Selector ls = yyResult.semanticValue();

          for (Selector s : l)  yyValue = new ExprChoiceSelect (yyValue, s);
          yyValue = new ExprChoiceSelect (yyValue, ls);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for l.

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTerm) 
      yyColumn.chunk2.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk2.fTerm;
  }

  /** Actually parse sketch.compiler.parser.Regen.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression base = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("[")) {

        yyResult = pExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression idx = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = ps(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new ExprArrayRange(base, idx);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'[' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pExprFuncInvok(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pExprNew(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pVar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new ExprParen (e);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 7.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("{|")) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue("|}")) {

          yyValue = new ExprParen (e);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'|}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("term expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.InfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fInfixOp) 
      yyColumn.chunk2.fInfixOp = pInfixOp$1(yyStart);
    return yyColumn.chunk2.fInfixOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.InfixOp. */
  private Result pInfixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pInOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("infix op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.InOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pInOp(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue.i |= op.i;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PrefixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrefixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrefixOp) 
      yyColumn.chunk2.fPrefixOp = pPrefixOp$1(yyStart);
    return yyColumn.chunk2.fPrefixOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.PrefixOp. */
  private Result pPrefixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("?")) {

        yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pPreOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = ps(yyBase);
          if (yyResult.hasValue("?")) {

            yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'?' expected", yyBase);
          }

          // Nested alternative 2.

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("prefix op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PreOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pPreOp(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue = new BI (yyValue.i | op.i);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PostfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPostfixOp) 
      yyColumn.chunk2.fPostfixOp = pPostfixOp$1(yyStart);
    return yyColumn.chunk2.fPostfixOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.PostfixOp. */
  private Result pPostfixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostfixOpNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("?")) {

        yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PostfixOpNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixOpNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPostfixOpNQ) 
      yyColumn.chunk2.fPostfixOpNQ = pPostfixOpNQ$1(yyStart);
    return yyColumn.chunk2.fPostfixOpNQ;
  }

  /** Actually parse sketch.compiler.parser.Regen.PostfixOpNQ. */
  private Result pPostfixOpNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pPostOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("postfix op n q expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PostOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pPostOp(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue = new BI (yyValue.i | op.i);;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Selector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelector(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelector) 
      yyColumn.chunk2.fSelector = pSelector$1(yyStart);
    return yyColumn.chunk2.fSelector;
  }

  /** Actually parse sketch.compiler.parser.Regen.Selector. */
  private Result pSelector$1(final int yyStart) throws IOException {
    Result     yyResult;
    Selector   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.SelectorNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectorNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelectorNQ) 
      yyColumn.chunk2.fSelectorNQ = pSelectorNQ$1(yyStart);
    return yyColumn.chunk2.fSelectorNQ;
  }

  /** Actually parse sketch.compiler.parser.Regen.SelectorNQ. */
  private Result pSelectorNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    Selector   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelectNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Select.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelect(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelect) 
      yyColumn.chunk2.fSelect = pSelect$1(yyStart);
    return yyColumn.chunk2.fSelect;
  }

  /** Actually parse sketch.compiler.parser.Regen.Select. */
  private Result pSelect$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pSelChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = ps(yyBase);
          if (yyResult.hasValue("?")) {

            yyValue = Select.clone (yyValue);  yyValue.setOptional (true);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'?' expected", yyBase);
          }

          // Nested alternative 2.

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("select expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.SelectNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectNQ(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pSelChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("select n q expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.SelChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChoice(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChoice) 
      yyColumn.chunk3.fSelChoice = pSelChoice$1(yyStart);
    return yyColumn.chunk3.fSelChoice;
  }

  /** Actually parse sketch.compiler.parser.Regen.SelChoice. */
  private Result pSelChoice$1(final int yyStart) throws IOException {
    Result     yyResult;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelChain(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSelChoice$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> l = yyResult.semanticValue();

        for (Select s : l)  yyValue = new SelectOrr (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * sketch.compiler.parser.Regen.SelChoice$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChoice$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChoice$$Star1) 
      yyColumn.chunk3.fSelChoice$$Star1 = pSelChoice$$Star1$1(yyStart);
    return yyColumn.chunk3.fSelChoice$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.SelChoice$$Star1. */
  private Result pSelChoice$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Select> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pSelChain(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Select v$el$1 = yyResult.semanticValue();

        yyResult = pSelChoice$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Select> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Select>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.SelChain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChain(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChain) 
      yyColumn.chunk3.fSelChain = pSelChain$1(yyStart);
    return yyColumn.chunk3.fSelChain;
  }

  /** Actually parse sketch.compiler.parser.Regen.SelChain. */
  private Result pSelChain$1(final int yyStart) throws IOException {
    Result     yyResult;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSelChain$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> l = yyResult.semanticValue();

        for (Select s : l)  yyValue = new SelectChain (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal sketch.compiler.parser.Regen.SelChain$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChain$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChain$$Star1) 
      yyColumn.chunk3.fSelChain$$Star1 = pSelChain$$Star1$1(yyStart);
    return yyColumn.chunk3.fSelChain$$Star1;
  }

  /** Actually parse sketch.compiler.parser.Regen.SelChain$$Star1. */
  private Result pSelChain$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Select> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Select v$el$1 = yyResult.semanticValue();

      yyResult = pSelChain$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Select>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Sel.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSel(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSel) yyColumn.chunk3.fSel = pSel$1(yyStart);
    return yyColumn.chunk3.fSel;
  }

  /** Actually parse sketch.compiler.parser.Regen.Sel. */
  private Result pSel$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue(".")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pId(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String id = yyResult.semanticValue();

        yyValue = new SelectField (id);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      if (yyResult.hasValue("??")) {

        yyValue = new SelectField("");

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'??' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("sel expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVar(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fVar) yyColumn.chunk3.fVar = pVar$1(yyStart);
    return yyColumn.chunk3.fVar;
  }

  /** Actually parse sketch.compiler.parser.Regen.Var. */
  private Result pVar$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String id = yyResult.semanticValue();

      yyValue = new ExprVar (getCx (), id);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      yyValue = ExprConstant.createConstant (getCx (), n);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("true")) {

      yyValue = ExprConstInt.one;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("false")) {

      yyValue = ExprConstInt.zero;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("null")) {

      yyValue = ExprNullPtr.nullPtr;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("??")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pExprBin(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression n1 = yyResult.semanticValue();

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyBase = yyChoice2;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyChoice2 + 1;

            yyResult = pExprBin(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression n2 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (')' == yyC) {
                yyIndex = yyResult.index + 1;

                int in1 = n1.getIValue();
                int in2 = n2.getIValue();
                yyValue = new ExprHole(getCx(),in1, in2);

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }

          // Nested alternative 2.

          yyBase = yyChoice2;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyChoice2 + 1;

            int in1 = n1.getIValue();
            yyValue = new ExprHole(getCx(),in1);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = new ExprHole (getCx ());

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.InOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fInOp) 
      yyColumn.chunk3.fInOp = pInOp$1(yyStart);
    return yyColumn.chunk3.fInOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.InOp. */
  private Result pInOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("||")) {

      yyValue = new BI (ExprChoiceBinary.LOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("&&")) {

      yyValue = new BI (ExprChoiceBinary.LAND);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("<<")) {

      yyValue = new BI (ExprChoiceBinary.LSHFT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = ps(yyStart);
    if (yyResult.hasValue(">>")) {

      yyValue = new BI (ExprChoiceBinary.RSHFT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("==")) {

      yyValue = new BI (ExprChoiceBinary.EQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("!=")) {

      yyValue = new BI (ExprChoiceBinary.NEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("<=")) {

      yyValue = new BI (ExprChoiceBinary.LTEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = ps(yyStart);
    if (yyResult.hasValue(">=")) {

      yyValue = new BI (ExprChoiceBinary.GTEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("\\|")) {

      yyValue = new BI (ExprChoiceBinary.BOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("^")) {

      yyValue = new BI (ExprChoiceBinary.BXOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("&")) {

      yyValue = new BI (ExprChoiceBinary.BAND);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("<")) {

      yyValue = new BI (ExprChoiceBinary.LT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyResult = ps(yyStart);
    if (yyResult.hasValue(">")) {

      yyValue = new BI (ExprChoiceBinary.GT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 14.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("+")) {

      yyValue = new BI (ExprChoiceBinary.ADD);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 15.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("-")) {

      yyValue = new BI (ExprChoiceBinary.SUB);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 16.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("*")) {

      yyValue = new BI (ExprChoiceBinary.MUL);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 17.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("/")) {

      yyValue = new BI (ExprChoiceBinary.DIV);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 18.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("%")) {

      yyValue = new BI (ExprChoiceBinary.MOD);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("in op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PreOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPreOp) 
      yyColumn.chunk3.fPreOp = pPreOp$1(yyStart);
    return yyColumn.chunk3.fPreOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.PreOp. */
  private Result pPreOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("++")) {

      yyValue = new BI (ExprChoiceUnary.PREINC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("--")) {

      yyValue = new BI (ExprChoiceUnary.PREDEC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("+")) {

      yyValue = new BI (0);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("-")) {

      yyValue = new BI (ExprChoiceUnary.NEG);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("!")) {

      yyValue = new BI (ExprChoiceUnary.NOT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("~")) {

      yyValue = new BI (ExprChoiceUnary.BNOT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pre op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.PostOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPostOp) 
      yyColumn.chunk3.fPostOp = pPostOp$1(yyStart);
    return yyColumn.chunk3.fPostOp;
  }

  /** Actually parse sketch.compiler.parser.Regen.PostOp. */
  private Result pPostOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("++")) {

      yyValue = new BI (ExprChoiceUnary.POSTINC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    if (yyResult.hasValue("--")) {

      yyValue = new BI (ExprChoiceUnary.POSTDEC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("post op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.WS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fs) yyColumn.chunk3.fs = ps$1(yyStart);
    return yyColumn.chunk3.fs;
  }

  /** Actually parse sketch.compiler.parser.Regen.s. */
  private Result ps$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSYM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.SYM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSYM(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '?':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('?' == yyC) {

              yyValue = "??";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "?";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '{':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('|' == yyC) {

              yyValue = "{|";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '}':
              {
                yyValue = "|}";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = "||";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('+' == yyC) {

              yyValue = "++";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('-' == yyC) {

              yyValue = "--";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('&' == yyC) {

              yyValue = "&&";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                yyValue = "<<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                yyValue = ">>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('|' == yyC) {

              yyValue = "\\|";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '^':
        {
          yyValue = "^";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '*':
        {
          yyValue = "*";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = "/";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '%':
        {
          yyValue = "%";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("SYM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fKeyword) 
      yyColumn.chunk4.fKeyword = pKeyword$1(yyStart);
    return yyColumn.chunk4.fKeyword;
  }

  /** Actually parse sketch.compiler.parser.Regen.Keyword. */
  private Result pKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKW(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.KW.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKW(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyValue = "true";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyValue = "false";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyValue = "null";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('w' == yyC) {

                    yyValue = "new";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("KW expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fId) yyColumn.chunk4.fId = pId$1(yyStart);
    return yyColumn.chunk4.fId;
  }

  /** Actually parse sketch.compiler.parser.Regen.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.ID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ID expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.Num.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNum(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal sketch.compiler.parser.Regen.NUM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNUM(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    int        yyOption2;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyOption1  = yyRepetition1;

      yyC = character(yyOption1);
      if ('.' == yyC) {
        yyIndex = yyOption1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyOption1  = yyRepetition1;
        }
      }


      yyResult = pNUM$$Choice1(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption2  = yyResult.index;

        final int yyChoice1 = yyOption2;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '+':
            {
              yyOption2  = yyIndex;
            }

          case '-':
            {
              yyOption2  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyRepetition1 = yyOption2;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyOption1  = yyRepetition1;
        }
      }


      yyC = character(yyOption1);
      if ('i' == yyC) {
        yyIndex = yyOption1 + 1;

        yyOption1  = yyIndex;
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("NUM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal sketch.compiler.parser.Regen.NUM$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNUM$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'e':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'E':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("NUM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  // TODO: get the line/column from Rats!
  private FEContext cx;
  public void setCx (FEContext cx) {  this.cx = cx;  }
  private FEContext getCx ()       {  return cx;  }
  
  private static class P<T1,T2> {
    public T1 one;  public T2 two;
    public P (T1 one, T2 two) {
      this.one = one;  this.two = two;
    }
  }
  
  private static class BI {
    public int i;  public BI(){this(0);}  public BI(int i){this.i = i;}
  }
  
  private Expression binExpr (Expression e, List l) {
    for (Object o : l) {
      P<BI,Expression> p = (P<BI,Expression>) o;
      e = new ExprChoiceBinary (e, p.one.i, p.two);
    }
    return e;
  }

}
